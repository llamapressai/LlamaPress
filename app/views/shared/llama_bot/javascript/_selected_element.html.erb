<style data-llama="exclude_when_saving_contenteditable_edits">
    .llama-inspector-overlay {
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    border: 2px solid #4299e1;
    background-color: rgba(66, 153, 225, 0.2);
    }

    .llama-inspector-overlay-margin {
        position: fixed;
        pointer-events: none;
        z-index: 9999;
        background-color: rgba(255, 215, 0, 0.4); /* Gold color */
    }

    .llama-inspector-overlay-padding {
        position: fixed;
        pointer-events: none;
        z-index: 9999;
        background-color: rgba(0, 255, 0, 0.4); /* Green color */
    }

    .llama-inspector-line {
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    background-color: #4299e1;
    display: none;
    }

    .llama-inspector-tooltip {
        position: fixed;
        z-index: 10000;
        background-color: white;
        color: #1a1a1a;
        padding: 12px;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        font-size: 14px;
        min-width: 300px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        pointer-events: auto;
        transition: all 0.3s ease-in-out;
    }

    .llama-inspector-dimensions {
      position: fixed;
      pointer-events: none;
      z-index: 10000;
      background-color: #1a202c;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
    }

    .llama-inspector-margin-dimensions {
      position: fixed;
      pointer-events: none;
      z-index: 10000;
      background-color: rgba(255, 215, 0, 0.9);
      color: #000;
      padding: 2px 4px;
      border-radius: 2px;
      font-size: 10px;
      font-family: monospace;
    }

    .llama-inspector-padding-dimensions {
      position: fixed;
      pointer-events: none;
      z-index: 10000;
      background-color: rgba(0, 255, 0, 0.9);
      color: #000;
      padding: 2px 4px;
      border-radius: 2px;
      font-size: 10px;
      font-family: monospace;
    }
</style>
<script data-llama="exclude_when_saving_contenteditable_edits">
  console.log("selected_element.html.erb");

// Add this before the ElementInspector class definition
window.llamaInspectorToggleClass = function(className, isChecked, llamaId) {
  const target = document.querySelector(`[data-llama-id="${llamaId}"]`);
  if (target) {
    if (isChecked) {
      target.classList.add(className);
    } else {
      target.classList.remove(className);
    }
  }
};

// script.js
class ElementInspector {
  constructor() {
    this.isActive = false;
    this.overlay = this.createOverlay();
    this.marginOverlays = this.createMarginOverlays();
    this.paddingOverlays = this.createPaddingOverlays();
    this.tooltip = this.createTooltip();
    this.lines = this.createLines();
    this.dimensionsLabel = this.createDimensionsLabel();
    this.marginLabels = this.createMarginLabels();
    this.paddingLabels = this.createPaddingLabels();
    this.init();
  }

  createOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'llama-inspector-overlay';
    document.body.appendChild(overlay);
    return overlay;
  }

  createMarginOverlays() {
    const overlays = ['top', 'right', 'bottom', 'left'].map(() => {
      const overlay = document.createElement('div');
      overlay.className = 'llama-inspector-overlay-margin';
      document.body.appendChild(overlay);
      return overlay;
    });
    return overlays;
  }

  createPaddingOverlays() {
    const overlays = ['top', 'right', 'bottom', 'left'].map(() => {
      const overlay = document.createElement('div');
      overlay.className = 'llama-inspector-overlay-padding';
      document.body.appendChild(overlay);
      return overlay;
    });
    return overlays;
  }

  createTooltip() {
    const tooltip = document.createElement('div');
    tooltip.className = 'llama-inspector-tooltip';
    
    // Create header banner
    const header = document.createElement('div');
    header.className = 'bg-gradient-to-r from-blue-600 to-blue-500 text-white p-2 flex justify-between items-center shadow-md rounded-t-md -mt-3 -mx-3 mb-2';
    
    // Add title
    const title = document.createElement('span');
    title.className = 'font-semibold text-lg';
    title.textContent = 'LlamaBot';
    
    // Add close button
    const closeButton = document.createElement('button');
    closeButton.className = 'text-2xl hover:text-blue-200 transition-colors duration-200';
    closeButton.innerHTML = '×';
    closeButton.onclick = () => {
      tooltip.style.display = 'none';
      this.hideAll();
    };
    
    this.toggleInspector(false);
    
    // Assemble header
    header.appendChild(title);
    header.appendChild(closeButton);
    
    // Add header to tooltip
    tooltip.appendChild(header);
    
    document.body.appendChild(tooltip);
    return tooltip;
  }

  createLines() {
    const lines = [];
    for (let i = 0; i < 8; i++) {
      const line = document.createElement('div');
      line.className = 'llama-inspector-line';
      document.body.appendChild(line);
      lines.push(line);
    }
    return lines;
  }

  createDimensionsLabel() {
    const label = document.createElement('div');
    label.className = 'llama-inspector-dimensions';
    document.body.appendChild(label);
    return label;
  }

  createMarginLabels() {
    return ['top', 'right', 'bottom', 'left'].map(() => {
      const label = document.createElement('div');
      label.className = 'llama-inspector-margin-dimensions';
      document.body.appendChild(label);
      return label;
    });
  }

  createPaddingLabels() {
    return ['top', 'right', 'bottom', 'left'].map(() => {
      const label = document.createElement('div');
      label.className = 'llama-inspector-padding-dimensions';
      document.body.appendChild(label);
      return label;
    });
  }

  toggleInspector(isActive) {
    this.isActive = isActive;
    console.log("selected element inspector is active: ", this.isActive);
    if (this.isActive) {
      document.body.style.cursor = 'crosshair';
      console.log("setting cursor to crosshair");
    } else {
      document.body.style.cursor = 'default';
      console.log("setting cursor to default");
      // remove the overlays
      //this.hideAll();
    }
  }

  init() {

    document.addEventListener('mousemove', (e) => {
      if (!this.isActive) return;

      const target = document.elementFromPoint(e.clientX, e.clientY);
      if (!target) return;

      const rect = target.getBoundingClientRect();
      const computedStyle = window.getComputedStyle(target);
      
      this.updateOverlays(rect, computedStyle);

      // Update tooltip
      const margin = {
        top: computedStyle.marginTop,
        right: computedStyle.marginRight,
        bottom: computedStyle.marginBottom,
        left: computedStyle.marginLeft
      };

      const padding = {
        top: computedStyle.paddingTop,
        right: computedStyle.paddingRight,
        bottom: computedStyle.paddingBottom,
        left: computedStyle.paddingLeft
      };

      this.tooltip.style.display = 'block';
      this.tooltip.style.left = `${e.clientX + 15}px`;
      this.tooltip.style.top = `${e.clientY + 15}px`;
      
      const classesHtml = target.classList.length
        ? Array.from(target.classList)
            .map(className => `
              <div class="class-item" style="
                display: inline-block;
                margin: 0 8px 8px 0;
                padding: 4px 8px;
                border: 1px solid #e5e7eb;
                border-radius: 999px;
                background-color: #f3f4f6;
              ">
                <label style="display: flex; align-items: center; gap: 8px; margin: 0;">
                  <input type="checkbox" 
                         checked 
                         onchange="llamaInspectorToggleClass('${className}', this.checked, '${target.dataset.llamaId || ''}')" 
                         class="class-toggle"
                         style="margin: 0;"
                  >
                  <span>${className}</span>
                </label>
              </div>
            `).join('')
        : '<div style="font-style: italic; color: #666;">No classes</div>';

      const contentHtml = `
        <div style="border-bottom: 1px solid #374151; padding-bottom: 8px; margin-bottom: 8px;">
          <strong>${target.tagName.toLowerCase()}</strong>
        </div>
        <div style="margin-bottom: 12px;">
          <div style="margin-bottom: 8px; color: #9CA3AF;">Classes:</div>
          <div style="max-height: 150px; overflow-y: auto; display: flex; flex-wrap: wrap;">
            ${classesHtml}
          </div>
        </div>
        <div style="border-top: 1px solid #374151; padding-top: 8px;">
          <input type="text" 
                 placeholder="What do you want to change?" 
                 class="llama-class-input"
                 onclick="toggleChat(); window.llamaElementInspector.toggleInspector(false); window.llamaElementInspector.hideAll();"
                 style="width: 100%; 
                        padding: 6px;
                        border-radius: 4px;
                        border: 1px solid #4B5563;
                        font-size: 12px;"
                 onkeydown="if(event.key === 'Enter') { 
                   const target = document.querySelector('[data-element-id=\\'${target.dataset.elementId || ''}\\']');
                   if(target) { 
                     target.classList.add(this.value);
                     this.value = '';
                   }
                 }"
          >
        </div>
      `;

      // Find or create a content container
      let contentContainer = this.tooltip.querySelector('.tooltip-content');
      if (!contentContainer) {
        contentContainer = document.createElement('div');
        contentContainer.className = 'tooltip-content';
        this.tooltip.appendChild(contentContainer);
      }
      contentContainer.innerHTML = contentHtml;

      // Update lines
      const linePositions = [
        // Top Left Corner
        { // Vertical line up
          left: rect.left,
          top: 0,
          width: '1px',
          height: `${rect.top}px`
        },
        { // Horizontal line left
          left: 0,
          top: rect.top,
          width: `${rect.left}px`,
          height: '1px'
        },
        
        // Top Right Corner
        { // Vertical line up
          left: rect.right,
          top: 0,
          width: '1px',
          height: `${rect.top}px`
        },
        { // Horizontal line right
          left: rect.right,
          top: rect.top,
          width: `${window.innerWidth - rect.right}px`,
          height: '1px'
        },

        // Bottom Left Corner
        { // Vertical line down
          left: rect.left,
          top: rect.bottom,
          width: '1px',
          height: `${window.innerHeight - rect.bottom}px`
        },
        { // Horizontal line left
          left: 0,
          top: rect.bottom,
          width: `${rect.left}px`,
          height: '1px'
        },

        // Bottom Right Corner
        { // Vertical line down
          left: rect.right,
          top: rect.bottom,
          width: '1px',
          height: `${window.innerHeight - rect.bottom}px`
        },
        { // Horizontal line right
          left: rect.right,
          top: rect.bottom,
          width: `${window.innerWidth - rect.right}px`,
          height: '1px'
        }
      ];

      this.lines.forEach((line, index) => {
        const pos = linePositions[index];
        line.style.display = 'block';
        line.style.left = `${pos.left}px`;
        line.style.top = `${pos.top}px`;
        line.style.width = pos.width;
        line.style.height = pos.height;
      });
    });

    document.addEventListener('mouseleave', () => {
      this.hideAll();
    });
  }

  hideAll() {

    //these conditional checks protect against nulls & undefineds
    if (this?.overlay) this.overlay.style.display = 'none';
    if (this?.tooltip) this.tooltip.style.display = 'none';
    this?.lines?.forEach(line => line && (line.style.display = 'none'));
    this?.marginOverlays?.forEach(overlay => overlay && (overlay.style.display = 'none'));
    this?.paddingOverlays?.forEach(overlay => overlay && (overlay.style.display = 'none'));
    if (this?.dimensionsLabel) this.dimensionsLabel.style.display = 'none';
    this?.marginLabels?.forEach(label => label && (label.style.display = 'none'));
    this?.paddingLabels?.forEach(label => label && (label.style.display = 'none'));
  }

  updateOverlays(rect, computedStyle) {
    // Update main element overlay (blue)
    this.overlay.style.display = 'block';
    this.overlay.style.left = `${rect.left}px`;
    this.overlay.style.top = `${rect.top}px`;
    this.overlay.style.width = `${rect.width}px`;
    this.overlay.style.height = `${rect.height}px`;
    this.overlay.style.backgroundColor = 'rgba(66, 153, 225, 0.2)';

    // Get computed margins and padding
    const margin = {
      top: parseFloat(computedStyle.marginTop),
      right: parseFloat(computedStyle.marginRight),
      bottom: parseFloat(computedStyle.marginBottom),
      left: parseFloat(computedStyle.marginLeft)
    };

    const padding = {
      top: parseFloat(computedStyle.paddingTop),
      right: parseFloat(computedStyle.paddingRight),
      bottom: parseFloat(computedStyle.paddingBottom),
      left: parseFloat(computedStyle.paddingLeft)
    };

    // Update margin overlays (gold)
    // Top margin
    this.marginOverlays[0].style.display = 'block';
    this.marginOverlays[0].style.left = `${rect.left - margin.left}px`;
    this.marginOverlays[0].style.top = `${rect.top - margin.top}px`;
    this.marginOverlays[0].style.width = `${rect.width + margin.left + margin.right}px`;
    this.marginOverlays[0].style.height = `${margin.top}px`;

    // Right margin
    this.marginOverlays[1].style.display = 'block';
    this.marginOverlays[1].style.left = `${rect.right}px`;
    this.marginOverlays[1].style.top = `${rect.top - margin.top}px`;
    this.marginOverlays[1].style.width = `${margin.right}px`;
    this.marginOverlays[1].style.height = `${rect.height + margin.top + margin.bottom}px`;

    // Bottom margin
    this.marginOverlays[2].style.display = 'block';
    this.marginOverlays[2].style.left = `${rect.left - margin.left}px`;
    this.marginOverlays[2].style.top = `${rect.bottom}px`;
    this.marginOverlays[2].style.width = `${rect.width + margin.left + margin.right}px`;
    this.marginOverlays[2].style.height = `${margin.bottom}px`;

    // Left margin
    this.marginOverlays[3].style.display = 'block';
    this.marginOverlays[3].style.left = `${rect.left - margin.left}px`;
    this.marginOverlays[3].style.top = `${rect.top - margin.top}px`;
    this.marginOverlays[3].style.width = `${margin.left}px`;
    this.marginOverlays[3].style.height = `${rect.height + margin.top + margin.bottom}px`;

    // Update padding overlays (green)
    // Top padding
    this.paddingOverlays[0].style.display = 'block';
    this.paddingOverlays[0].style.left = `${rect.left}px`;
    this.paddingOverlays[0].style.top = `${rect.top}px`;
    this.paddingOverlays[0].style.width = `${rect.width}px`;
    this.paddingOverlays[0].style.height = `${padding.top}px`;

    // Right padding
    this.paddingOverlays[1].style.display = 'block';
    this.paddingOverlays[1].style.left = `${rect.right - padding.right}px`;
    this.paddingOverlays[1].style.top = `${rect.top}px`;
    this.paddingOverlays[1].style.width = `${padding.right}px`;
    this.paddingOverlays[1].style.height = `${rect.height}px`;

    // Bottom padding
    this.paddingOverlays[2].style.display = 'block';
    this.paddingOverlays[2].style.left = `${rect.left}px`;
    this.paddingOverlays[2].style.top = `${rect.bottom - padding.bottom}px`;
    this.paddingOverlays[2].style.width = `${rect.width}px`;
    this.paddingOverlays[2].style.height = `${padding.bottom}px`;

    // Left padding
    this.paddingOverlays[3].style.display = 'block';
    this.paddingOverlays[3].style.left = `${rect.left}px`;
    this.paddingOverlays[3].style.top = `${rect.top}px`;
    this.paddingOverlays[3].style.width = `${padding.left}px`;
    this.paddingOverlays[3].style.height = `${rect.height}px`;

    // Update dimensions label
    this.dimensionsLabel.style.display = 'block';
    this.dimensionsLabel.style.left = `${rect.right - 5}px`;  // 5px offset from right
    this.dimensionsLabel.style.top = `${rect.top - 25}px`;    // 25px above the element
    this.dimensionsLabel.textContent = `${Math.round(rect.width)} × ${Math.round(rect.height)}`;
    
    // Add transform to shift the label left by its own width
    this.dimensionsLabel.style.transform = 'translateX(-100%)';

    // Update margin labels
    const marginValues = {
      top: margin.top,
      right: margin.right,
      bottom: margin.bottom,
      left: margin.left
    };

    // Position labels inside margin overlays
    this.marginLabels.forEach((label, index) => {
      const side = ['top', 'right', 'bottom', 'left'][index];
      label.style.display = marginValues[side] > 0 ? 'block' : 'none';
      label.textContent = `${Math.round(marginValues[side])}px`;

      switch(side) {
        case 'top':
          label.style.left = `${rect.left + rect.width / 2}px`;
          label.style.top = `${rect.top - margin.top / 2}px`;
          label.style.transform = 'translate(-50%, -50%)';
          break;
        case 'right':
          label.style.left = `${rect.right + margin.right / 2}px`;
          label.style.top = `${rect.top + rect.height / 2}px`;
          label.style.transform = 'translate(-50%, -50%)';
          break;
        case 'bottom':
          label.style.left = `${rect.left + rect.width / 2}px`;
          label.style.top = `${rect.bottom + margin.bottom / 2}px`;
          label.style.transform = 'translate(-50%, -50%)';
          break;
        case 'left':
          label.style.left = `${rect.left - margin.left / 2}px`;
          label.style.top = `${rect.top + rect.height / 2}px`;
          label.style.transform = 'translate(-50%, -50%)';
          break;
      }
    });

    // Update padding labels
    const paddingValues = {
      top: padding.top,
      right: padding.right,
      bottom: padding.bottom,
      left: padding.left
    };

    // Position labels inside padding overlays
    this.paddingLabels.forEach((label, index) => {
      const side = ['top', 'right', 'bottom', 'left'][index];
      label.style.display = paddingValues[side] > 0 ? 'block' : 'none';
      label.textContent = `${Math.round(paddingValues[side])}px`;

      switch(side) {
        case 'top':
          label.style.left = `${rect.left + rect.width / 2}px`;
          label.style.top = `${rect.top + padding.top / 2}px`;
          label.style.transform = 'translate(-50%, -50%)';
          break;
        case 'right':
          label.style.left = `${rect.right - padding.right / 2}px`;
          label.style.top = `${rect.top + rect.height / 2}px`;
          label.style.transform = 'translate(-50%, -50%)';
          break;
        case 'bottom':
          label.style.left = `${rect.left + rect.width / 2}px`;
          label.style.top = `${rect.bottom - padding.bottom / 2}px`;
          label.style.transform = 'translate(-50%, -50%)';
          break;
        case 'left':
          label.style.left = `${rect.left + padding.left / 2}px`;
          label.style.top = `${rect.top + rect.height / 2}px`;
          label.style.transform = 'translate(-50%, -50%)';
          break;
      }
    });
  }  
}

// Initialize the inspector
const llamaElementInspector = new ElementInspector();
window.llamaElementInspector = llamaElementInspector;
</script>