<style>
    .llama-inspector-overlay {
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    border: 2px solid #4299e1;
    background-color: rgba(66, 153, 225, 0.2);
    }

    .llama-inspector-overlay-margin {
        position: fixed;
        pointer-events: none;
        z-index: 9999;
        background-color: rgba(255, 215, 0, 0.4); /* Gold color */
    }

    .llama-inspector-overlay-padding {
        position: fixed;
        pointer-events: none;
        z-index: 9999;
        background-color: rgba(0, 255, 0, 0.4); /* Green color */
    }

    .llama-inspector-line {
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    background-color: #4299e1;
    display: none;
    }

    .llama-inspector-tooltip {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    background-color: #1a202c;
    color: white;
    padding: 8px;
    border-radius: 4px;
    font-size: 12px;
    display: none;
    }

    .llama-inspector-dimensions {
      position: fixed;
      pointer-events: none;
      z-index: 10000;
      background-color: #1a202c;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
    }
</style>
<script>
  console.log("selected_element.html.erb");
// script.js
class ElementInspector {
  constructor() {
    this.isActive = false;
    this.overlay = this.createOverlay();
    this.marginOverlays = this.createMarginOverlays();
    this.paddingOverlays = this.createPaddingOverlays();
    this.tooltip = this.createTooltip();
    this.lines = this.createLines();
    this.dimensionsLabel = this.createDimensionsLabel();
    this.init();
  }

  createOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'llama-inspector-overlay';
    document.body.appendChild(overlay);
    return overlay;
  }

  createMarginOverlays() {
    const overlays = ['top', 'right', 'bottom', 'left'].map(() => {
      const overlay = document.createElement('div');
      overlay.className = 'llama-inspector-overlay-margin';
      document.body.appendChild(overlay);
      return overlay;
    });
    return overlays;
  }

  createPaddingOverlays() {
    const overlays = ['top', 'right', 'bottom', 'left'].map(() => {
      const overlay = document.createElement('div');
      overlay.className = 'llama-inspector-overlay-padding';
      document.body.appendChild(overlay);
      return overlay;
    });
    return overlays;
  }

  createTooltip() {
    const tooltip = document.createElement('div');
    tooltip.className = 'llama-inspector-tooltip';
    document.body.appendChild(tooltip);
    return tooltip;
  }

  createLines() {
    const lines = [];
    for (let i = 0; i < 8; i++) {
      const line = document.createElement('div');
      line.className = 'llama-inspector-line';
      document.body.appendChild(line);
      lines.push(line);
    }
    return lines;
  }

  createDimensionsLabel() {
    const label = document.createElement('div');
    label.className = 'llama-inspector-dimensions';
    document.body.appendChild(label);
    return label;
  }

  init() {
    document.addEventListener('keydown', (e) => {
      if (e.key === 'i') {
        console.log("i key pressed");
        this.isActive = !this.isActive;
        console.log("selected element inspector is active: ", this.isActive);
        document.body.style.cursor = this.isActive ? 'crosshair' : 'default';
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (!this.isActive) return;

      const target = document.elementFromPoint(e.clientX, e.clientY);
      if (!target) return;

      const rect = target.getBoundingClientRect();
      const computedStyle = window.getComputedStyle(target);
      
      this.updateOverlays(rect, computedStyle);

      // Update tooltip
      const margin = {
        top: computedStyle.marginTop,
        right: computedStyle.marginRight,
        bottom: computedStyle.marginBottom,
        left: computedStyle.marginLeft
      };

      const padding = {
        top: computedStyle.paddingTop,
        right: computedStyle.paddingRight,
        bottom: computedStyle.paddingBottom,
        left: computedStyle.paddingLeft
      };

      this.tooltip.style.display = 'block';
      this.tooltip.style.left = `${e.clientX + 15}px`;
      this.tooltip.style.top = `${e.clientY + 15}px`;
      
      const classesHtml = target.classList.length 
        ? Array.from(target.classList)
            .map(className => `
              <label style="display: inline-block; margin-right: 8px;">
                <input type="checkbox" 
                       checked 
                       onchange="toggleClass('${className}', this.checked, '${target.dataset.elementId || ''}')" 
                       class="class-toggle"
                > ${className}
              </label>
            `).join('')
        : 'none';

      this.tooltip.innerHTML = `
        <div>Element: ${target.tagName.toLowerCase()}</div>
        <div>Classes: ${classesHtml}</div>
        <div>Size: ${Math.round(rect.width)}px × ${Math.round(rect.height)}px</div>
        <div>Margin: ${margin.top} ${margin.right} ${margin.bottom} ${margin.left}</div>
        <div>Padding: ${padding.top} ${padding.right} ${padding.bottom} ${padding.left}</div>
      `;

      // Update lines
      const linePositions = [
        // Top Left Corner
        { // Vertical line up
          left: rect.left,
          top: 0,
          width: '1px',
          height: `${rect.top}px`
        },
        { // Horizontal line left
          left: 0,
          top: rect.top,
          width: `${rect.left}px`,
          height: '1px'
        },
        
        // Top Right Corner
        { // Vertical line up
          left: rect.right,
          top: 0,
          width: '1px',
          height: `${rect.top}px`
        },
        { // Horizontal line right
          left: rect.right,
          top: rect.top,
          width: `${window.innerWidth - rect.right}px`,
          height: '1px'
        },

        // Bottom Left Corner
        { // Vertical line down
          left: rect.left,
          top: rect.bottom,
          width: '1px',
          height: `${window.innerHeight - rect.bottom}px`
        },
        { // Horizontal line left
          left: 0,
          top: rect.bottom,
          width: `${rect.left}px`,
          height: '1px'
        },

        // Bottom Right Corner
        { // Vertical line down
          left: rect.right,
          top: rect.bottom,
          width: '1px',
          height: `${window.innerHeight - rect.bottom}px`
        },
        { // Horizontal line right
          left: rect.right,
          top: rect.bottom,
          width: `${window.innerWidth - rect.right}px`,
          height: '1px'
        }
      ];

      this.lines.forEach((line, index) => {
        const pos = linePositions[index];
        line.style.display = 'block';
        line.style.left = `${pos.left}px`;
        line.style.top = `${pos.top}px`;
        line.style.width = pos.width;
        line.style.height = pos.height;
      });
    });

    document.addEventListener('mouseleave', () => {
      this.hideAll();
    });
  }

  hideAll() {
    this.overlay.style.display = 'none';
    this.tooltip.style.display = 'none';
    this.lines.forEach(line => line.style.display = 'none');
    this.marginOverlays.forEach(overlay => overlay.style.display = 'none');
    this.paddingOverlays.forEach(overlay => overlay.style.display = 'none');
    this.dimensionsLabel.style.display = 'none';
  }

  toggleClass(className, isChecked, elementId) {
    const target = document.querySelector(`[data-element-id="${elementId}"]`);
    if (target) {
        if (isChecked) {
            target.classList.add(className);
        } else {
            target.classList.remove(className);
        }
    }
  }  

  updateOverlays(rect, computedStyle) {
    // Update main element overlay (blue)
    this.overlay.style.display = 'block';
    this.overlay.style.left = `${rect.left}px`;
    this.overlay.style.top = `${rect.top}px`;
    this.overlay.style.width = `${rect.width}px`;
    this.overlay.style.height = `${rect.height}px`;
    this.overlay.style.backgroundColor = 'rgba(66, 153, 225, 0.2)';

    // Get computed margins and padding
    const margin = {
      top: parseFloat(computedStyle.marginTop),
      right: parseFloat(computedStyle.marginRight),
      bottom: parseFloat(computedStyle.marginBottom),
      left: parseFloat(computedStyle.marginLeft)
    };

    const padding = {
      top: parseFloat(computedStyle.paddingTop),
      right: parseFloat(computedStyle.paddingRight),
      bottom: parseFloat(computedStyle.paddingBottom),
      left: parseFloat(computedStyle.paddingLeft)
    };

    // Update margin overlays (gold)
    // Top margin
    this.marginOverlays[0].style.display = 'block';
    this.marginOverlays[0].style.left = `${rect.left - margin.left}px`;
    this.marginOverlays[0].style.top = `${rect.top - margin.top}px`;
    this.marginOverlays[0].style.width = `${rect.width + margin.left + margin.right}px`;
    this.marginOverlays[0].style.height = `${margin.top}px`;

    // Right margin
    this.marginOverlays[1].style.display = 'block';
    this.marginOverlays[1].style.left = `${rect.right}px`;
    this.marginOverlays[1].style.top = `${rect.top - margin.top}px`;
    this.marginOverlays[1].style.width = `${margin.right}px`;
    this.marginOverlays[1].style.height = `${rect.height + margin.top + margin.bottom}px`;

    // Bottom margin
    this.marginOverlays[2].style.display = 'block';
    this.marginOverlays[2].style.left = `${rect.left - margin.left}px`;
    this.marginOverlays[2].style.top = `${rect.bottom}px`;
    this.marginOverlays[2].style.width = `${rect.width + margin.left + margin.right}px`;
    this.marginOverlays[2].style.height = `${margin.bottom}px`;

    // Left margin
    this.marginOverlays[3].style.display = 'block';
    this.marginOverlays[3].style.left = `${rect.left - margin.left}px`;
    this.marginOverlays[3].style.top = `${rect.top - margin.top}px`;
    this.marginOverlays[3].style.width = `${margin.left}px`;
    this.marginOverlays[3].style.height = `${rect.height + margin.top + margin.bottom}px`;

    // Update padding overlays (green)
    // Top padding
    this.paddingOverlays[0].style.display = 'block';
    this.paddingOverlays[0].style.left = `${rect.left}px`;
    this.paddingOverlays[0].style.top = `${rect.top}px`;
    this.paddingOverlays[0].style.width = `${rect.width}px`;
    this.paddingOverlays[0].style.height = `${padding.top}px`;

    // Right padding
    this.paddingOverlays[1].style.display = 'block';
    this.paddingOverlays[1].style.left = `${rect.right - padding.right}px`;
    this.paddingOverlays[1].style.top = `${rect.top}px`;
    this.paddingOverlays[1].style.width = `${padding.right}px`;
    this.paddingOverlays[1].style.height = `${rect.height}px`;

    // Bottom padding
    this.paddingOverlays[2].style.display = 'block';
    this.paddingOverlays[2].style.left = `${rect.left}px`;
    this.paddingOverlays[2].style.top = `${rect.bottom - padding.bottom}px`;
    this.paddingOverlays[2].style.width = `${rect.width}px`;
    this.paddingOverlays[2].style.height = `${padding.bottom}px`;

    // Left padding
    this.paddingOverlays[3].style.display = 'block';
    this.paddingOverlays[3].style.left = `${rect.left}px`;
    this.paddingOverlays[3].style.top = `${rect.top}px`;
    this.paddingOverlays[3].style.width = `${padding.left}px`;
    this.paddingOverlays[3].style.height = `${rect.height}px`;

    // Update dimensions label
    this.dimensionsLabel.style.display = 'block';
    this.dimensionsLabel.style.left = `${rect.right - 5}px`;  // 5px offset from right
    this.dimensionsLabel.style.top = `${rect.top - 25}px`;    // 25px above the element
    this.dimensionsLabel.textContent = `${Math.round(rect.width)} × ${Math.round(rect.height)}`;
    
    // Add transform to shift the label left by its own width
    this.dimensionsLabel.style.transform = 'translateX(-100%)';
  }
}

// Initialize the inspector
const inspector = new ElementInspector();

</script>
