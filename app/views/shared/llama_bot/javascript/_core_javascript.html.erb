<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script data-llama="exclude_when_saving_contenteditable_edits">
  // Make sure these are at the top of the file, outside any functions
  // Add these lines at the very top, before any other JavaScript
  window.messageTraces = {}; // Make it global
  window.currentReaction = {
    messageId: null,
    type: null, 
    button: null
  };

  window.uncaughtErrors = [];

  window.onerror = function(message, source, lineno, colno, error) {
    // Check if the error source is from the same origin and path
    const errUrl = new URL(source)

    const isSameOrigin = errUrl.origin === location.origin;
    const isSamePath = errUrl.pathname === location.pathname;
    const thisErrorOriginatedFromCurrentPage = isSameOrigin && isSamePath;

    if (thisErrorOriginatedFromCurrentPage) {
      uncaughtErrors.push({
          message,
          source,
          lineno,
          colno,
          error,
      });
      incrementDebugBadge();
    }
  };


  document.addEventListener("DOMContentLoaded", () => {
    const chatIcon = document.getElementById("chatIcon");
    const chatbotContainer = document.getElementById("chatbotContainer");
    const closeButton = document.getElementById("closeButton");
    const chatbotMessagesContainer = document.getElementById("chatbotMessagesContainer");
    const userInput = document.getElementById("userInput");
    const sendButton = document.getElementById("sendButton");

    const modal = document.getElementById("historyModal");
    const closeModal = document.getElementById("closeModal");
    const leftArrow = document.getElementById("leftArrow");
    const rightArrow = document.getElementById("rightArrow");

    /**
     * Sends the user's message from this Chat UI Frontend to LlamaBot.
     * Handles all the UI logic for sending the message, displaying the new message, and showing the loading indicator, hiding chat tool windows, etc.
     */
    async function sendMessageToLlamaBot() {
      if (userInput.value.trim() === "" || isLoading) return;

      const connectionStatusIconForLlamaBot = document.getElementById('connectionStatusIconForLlamaBot');
      const isYellow = connectionStatusIconForLlamaBot.classList.contains('bg-yellow-400');

      let userMessage = userInput.value;
      addMessage(userMessage, "user");
      userInput.value = "";
      autoResizeUserInputArea();
      isLoading = true;
      showLoadingIndicator();

      if (isYellow) {
        const MAX_ATTEMPTS = 10;
        let attempts = 0;

        while (attempts < MAX_ATTEMPTS) {
          attempts++;
          const connectionStatusIconForLlamaBot = document.getElementById('connectionStatusIconForLlamaBot');
          const isYellow = connectionStatusIconForLlamaBot.classList.contains('bg-yellow-400');
          if (!isYellow) {
            addMessage("LlamaBot is online. Sending message now!", "bot");
            addMessage(userMessage, "user");
            break;
          }
          else {
            addMessage("Connecting to LlamaBot.. Attempt " + attempts + " of " + MAX_ATTEMPTS, "bot");
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }

        if (attempts >= MAX_ATTEMPTS) {
          addMessage("Error: Failed to connect to LlamaBot. Refresh page & try again.", "error");
        }
      }


      //remove all selectedElement class so it doesn't get sent into LLM and get saved in database.
      let selectedElement = document.getElementById("selectedElementContent");

      let selectedElementInnerHtml = selectedElement.innerHTML.trim() || null; //trim to remove any whitespace or newline characters

      if (selectedElementInnerHtml) {
        selectedElementInnerHtml = selectedElementInnerHtml.replace(
          "selected-element",
          ""
        );
      }

      if (debugModeToggle.checked) {
        userMessage = " [debug mode toggled]: " + userMessage;
      }

      hideAllChatToolWindows();

      sendUserMessageOverSocket(
        userMessage, 
        selectedElementInnerHtml, 
        (error) => {
          console.error("Error sending message:", error);
        }, 
        get_relevant_errors());
    }

  function get_relevant_errors() {
    /**
    * Strip out errors that aren't from the current page.
    * @param {Array<{source: string}>} errors
    * @returns {Array<object>}  Only the relevant errors.
    */
    const relevantErrors = uncaughtErrors.reduce((acc, item) => {
      try {
        const errUrl = new URL(item.source);                        // parse the error's URL
        if (
          errUrl.origin === location.origin &&                      // same protocol+host(+port)
          errUrl.pathname === location.pathname                     // same path
        ) {
          acc.push(item);                                           // keep it
        }
      } catch (_) {
          /* ignore malformed URLs */
        }
        return acc;
      }, []);

      return formatErrors(relevantErrors);
  }
  
  window.get_relevant_errors = get_relevant_errors;
    
    function formatErrors(errors) {
        return errors.map(e => {
            return `Error Message: ${e.message}
            Source URL: ${e.source}
            Line: ${e.lineno}, Column: ${e.colno}`;
                }).join('\n\n');
    }

    window.formatErrors = formatErrors;


    /**
     * Helper to show the loading indicator for when llamabot is thinking, called from sendMessageToLlamaBot.
     */
    function showLoadingIndicator() {
      // show all instances of is-thinking class
      document.querySelectorAll(".is-thinking").forEach(element => {
        element.classList.remove("hidden");
      });
      const spinner = makeLoadingSpinner();
      const loadingDiv = document.createElement("div");
      loadingDiv.id = "loadingIndicator";
      loadingDiv.classList.add("is-thinking");
      loadingDiv.appendChild(spinner);
      chatbotMessagesContainer.appendChild(loadingDiv);
    }

    /**
     * Helper method to hides the loading indicator for when llamabot is done thinking.
     */
    function hideLoadingIndicator() {
      isLoading = false;
      // hide all instances of is-thinking class
      document.querySelectorAll(".is-thinking").forEach(element => {
        element.classList.add("hidden");
      });

      const loadingDiv = document.getElementById("loadingIndicator");
      if (loadingDiv) {
        loadingDiv.remove();
      }
    }
    window.hideLoadingIndicator = hideLoadingIndicator;


    closeModal.addEventListener("click", () => {
      modal.classList.add("hidden");
      modal.classList.remove("flex");
    });

    leftArrow.addEventListener("click", () => {
      // Implement left navigation logic
    });

    rightArrow.addEventListener("click", () => {
      // Implement right navigation logic
    });

    var isOpen = true; // isopen is true by default now.
    let isLoading = false;
    let messages = [];

    ///** global getter for isOpen, needed for accessing isOpen when in closures */
    function getIsOpen(){
      return isOpen;
    }
    window.getIsOpen = getIsOpen;
  
    /**
     * Toggles the chat window to show llamabot chat
     */
    function toggleChat(shouldOpen = null) {
      //TODO: We should allow user to pass in boolean to toggle chat to open or closed, but right now it's always passing in a pointer event, which is confusing.

      //if (shouldOpen === null) {
      //  console.log("Chat window has been toggled");
      //  isOpen = !isOpen;
      //  chatbotContainer.classList.toggle("hidden", !isOpen);
      //
      //  const chatbotMessagesContainer = document.getElementById('chatbotMessagesContainer');            
      //  chatbotMessagesContainer.scrollTop = chatbotMessagesContainer.scrollHeight;
      //}
      //else {
        isOpen = !isOpen;
        chatbotContainer.classList.toggle("hidden", !isOpen);

        console.log("Chat window has been toggled to " + (isOpen ? "open" : "closed"));
        const chatbotMessagesContainer = document.getElementById('chatbotMessagesContainer');            
        chatbotMessagesContainer.scrollTop = chatbotMessagesContainer.scrollHeight;
      //}
    }

    // Expose toggleChat to the global scope
    window.toggleChat = toggleChat;

    // Add event listeners to the chat icon and close button
    chatIcon.addEventListener("click", () => {
      // If we're in selection mode, exit it
      if (inSelectionMode) {
        toggleSelectionMode();
        return; // Don't toggle chat if we were in selection mode
      }
      
      // Normal chat toggle behavior
      toggleChat();
    });
    closeButton.addEventListener("click", toggleChat);

    /**
     * WARNING: This is duplicated code in _websocket.html.erb. This is really ugly. Formats the message to display code blocks properly
     * This was used to format code blocks so that the user could see formatted code when the chatbot responds.
     */
    function formatMessage(text, sender) {
      // Custom renderer to handle code blocks
      const renderer = new marked.Renderer();
      renderer.code = (code) => {
        return code;
      };

      // Configure marked options
      marked.setOptions({
        renderer: renderer,
        highlight: (code, lang) => {
          const language = Prism.languages[lang] ? lang : 'markup';
          return Prism.highlight(code, Prism.languages[language], language);
        },
        breaks: true,
        gfm: true
      });

      // Parse the markdown
      if (sender == "user") {
        return marked.parse(escapeHtml(text));
      }
      else {
        return marked.parse(text);
      }
    }

    /**
     * Escapes HTML characters for code formatting
     */
    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }



    /**
     * Adds a message to the chatbot messages container.
     */
    function addMessage(text, sender, onClickCallback = null, appendToTop = false, createdAt = null) {
      const wrapper = document.createElement("div");
      wrapper.className = "mb-4 flex items-start";

      // Timeline visualization
      const timeline = document.createElement("div");
      timeline.className = "mr-4 flex flex-col items-center";
      
      const dot = document.createElement("div");
      dot.className = `w-3 h-3 rounded-full ${sender === "bot" ? "bg-blue-500" : "bg-green-500"}`;
      
      const line = document.createElement("div");
      line.className = "w-0.5 h-full bg-gray-300 -mt-2";
      
      timeline.appendChild(dot);
      timeline.appendChild(line);

      const contentWrapper = document.createElement("div");
      contentWrapper.className = "flex-grow";

      const labelContainer = document.createElement("div");
      labelContainer.className = "flex items-center mb-1";

      const timestamp = document.createElement("span");
      timestamp.className = "text-xs text-gray-500 mr-2";
      timestamp.textContent = createdAt ? new Date(createdAt).toLocaleString() : new Date().toLocaleString();

      const label = document.createElement("span");
      label.className = "text-xs text-gray-700 font-semibold";
      label.textContent = sender === "bot" ? "Llama Bot" : "<%=current_user&.email%>";

      labelContainer.appendChild(timestamp);
      labelContainer.appendChild(label);
      contentWrapper.appendChild(labelContainer);

      const messageDiv = document.createElement("div");
      //TODO: This is a hacky way to format our message to format styling.
                // We need to DRY up this code
                // Right now, similar logic is happening in multiple places: _websocket.html.erb, _core_javascript.html.erb
      messageDiv.className = `p-2 rounded ${
        sender === "bot" ? "bg-blue-100" : 
        sender === "user" ? "bg-green-100" : 
        sender === "error" ? "bg-red-100" : 
        sender === "system" ? "bg-yellow-100" : 
        sender === "tool" ? "bg-gray-50 border border-gray-200 text-xs text-gray-600 px-3 py-1" : 
        "bg-gray-100"
      }`;
      
      const formattedContent = formatMessage(text, sender);
      messageDiv.innerHTML = formattedContent;
      
      contentWrapper.appendChild(messageDiv);
      wrapper.appendChild(timeline);
      wrapper.appendChild(contentWrapper);

      if (appendToTop) {
        chatbotMessagesContainer.insertBefore(wrapper, chatbotMessagesContainer.firstChild);
      } else {
        chatbotMessagesContainer.appendChild(wrapper);
        chatbotMessagesContainer.scrollTop = chatbotMessagesContainer.scrollHeight;
      }
      
      if (onClickCallback) {
        messageDiv.addEventListener("click", onClickCallback);
      }
    }

    /**
     * Creates a loading spinner for the chatbot.
     */
    function makeLoadingSpinner() {
      const spinner = document.createElement("div");
      spinner.innerHTML = `
        <div class="grid grid-cols-[40px_auto] gap-4 items-center w-full">
            <div class="grid min-h-[20px] w-full place-items-center overflow-hidden rounded-lg p-6">
        <svg class="text-gray-300 animate-spin" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg"
            width="24" height="24">
            <path
            d="M32 3C35.8083 3 39.5794 3.75011 43.0978 5.20749C46.6163 6.66488 49.8132 8.80101 52.5061 11.4939C55.199 14.1868 57.3351 17.3837 58.7925 20.9022C60.2499 24.4206 61 28.1917 61 32C61 35.8083 60.2499 39.5794 58.7925 43.0978C57.3351 46.6163 55.199 49.8132 52.5061 52.5061C49.8132 55.199 46.6163 57.3351 43.0978 58.7925C39.5794 60.2499 35.8083 61 32 61C28.1917 61 24.4206 60.2499 20.9022 58.7925C17.3837 57.3351 14.1868 55.199 11.4939 52.5061C8.801 49.8132 6.66487 46.6163 5.20749 43.0978C3.7501 39.5794 3 35.8083 3 32C3 28.1917 3.75011 24.4206 5.2075 20.9022C6.66489 17.3837 8.80101 14.1868 11.4939 11.4939C14.1868 8.80099 17.3838 6.66487 20.9022 5.20749C24.4206 3.7501 28.1917 3 32 3L32 3Z"
            stroke="currentColor" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"></path>
            <path
            d="M32 3C36.5778 3 41.0906 4.08374 45.1692 6.16256C49.2477 8.24138 52.7762 11.2562 55.466 14.9605C58.1558 18.6647 59.9304 22.9531 60.6448 27.4748C61.3591 31.9965 60.9928 36.6232 59.5759 40.9762"
            stroke="currentColor" stroke-width="5" stroke-linecap="round" stroke-linejoin="round" class="text-gray-900">
            </path>
        </svg>
        </div>
        <span class="thinking-pulse">Thinking... (this may take a while)</span>
        </div>`.trim();
      return spinner.firstElementChild;
    }

    /**
     * Toggles to show/hide the prompts container.
     */
    function togglePromptsContainer() {
      document.getElementById('promptsContainer').classList.toggle("hidden");
    }
    //make global access to toggle prompts container
    window.togglePromptsContainer = togglePromptsContainer;

    /**
     * Inserts a prompt into the user input area and sends the message to the LLM.
     */
    function insertPrompt(prompt) {
      userInput.value = prompt;
      sendMessageToLlamaBot();
    }
    //make global access to insert prompt
    window.insertPrompt = insertPrompt;

    /**
     * Hides all chat tool windows.
     */
    function hideAllChatToolWindows() {
      //hide all chat tool windows
      document.getElementById("promptsContainer").classList.add("hidden");
      document.getElementById("imagesForUserToSelect").style.display = "none";

      
      // clear selected element 
      document.getElementById("selectedElementContainer").style.display =
        "none";
      document.getElementById("selectedElementContent").innerHTML = "";
      document.getElementById("debugContainer").classList.add("hidden");
      


    }
    //make global access to hide all chat tool windows
    window.hideAllChatToolWindows = hideAllChatToolWindows;

    sendButton.addEventListener("click", sendMessageToLlamaBot);
    
    userInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        if (e.shiftKey || e.altKey || e.metaKey) {
          // Allow new line on Shift+Enter, Option(Alt)+Enter, or Command(Meta)+Enter
          return;
        }
        e.preventDefault(); // Prevent default Enter behavior
        sendMessageToLlamaBot();
      }
    });

    let currentPageOfHistory = 1;
    let isLoadingMoreHistory = false;
    let hasMorePagesOfHistory = true;

    /**
     * Loads the chat history for the current web page and puts it into the modal history drawer.
     */
    function loadChatHistory(page = 1) {
      let webPageId = "<%=@page&.id%>";
      if (webPageId && !isLoadingMoreHistory && hasMorePagesOfHistory) {
        isLoadingMoreHistory = true;
        
        fetch(`/pages/${webPageId}/histories.json?page=${page}`)
          .then((response) => {
            if (!response.ok) {
              throw new Error("Network response was not ok");
            }
            return response.json();
          })
          .then((data) => {
            const histories = data.history_items;
            
            // Update pagination state
            currentPageOfHistory = data.meta.current_page;
            hasMorePagesOfHistory = currentPageOfHistory < data.meta.total_pages;
            
            // For first page, reverse to show newest at bottom
            // For subsequent pages (older messages), maintain order
            const orderedHistories = page === 1 ? histories.reverse() : histories;
          
            orderedHistories.forEach((history) => {
              if (history.type === "page_history") {
                addPageHistoryToMessagesArea(history, page !== 1);
              } else {
                addMessage(history.content, history.role, null, true, history.created_at); //append to top
              }
            });

            if (page === 1) {
              // Only do these for initial load
              const chatbotMessagesContainer = document.getElementById('chatbotMessagesContainer');            
              chatbotMessagesContainer.scrollTop = chatbotMessagesContainer.scrollHeight;
              addMessage("What do you want to change?", "bot");
              document.dispatchEvent(new CustomEvent('llamaChatHistoryLoaded'));
            }
          })
          .catch(error => {
            console.error('Error loading chat history:', error);
          })
          .finally(() => {
            isLoadingMoreHistory = false;
          });
      }
    }

    // Add scroll event listener to load more message history when user scrolls near the top
    document.getElementById('chatbotMessagesContainer').addEventListener('scroll', function(e) {
      const element = e.target;
      // Load more when user scrolls near the top (for older messages)
      if (element.scrollTop <= element.clientHeight * 0.05) { // when user is at least 5% from top, load more history
        if (!isLoadingMoreHistory && hasMorePagesOfHistory) {
          loadChatHistory(currentPageOfHistory + 1);
        }
      }
    });

    /**
     * Creates a history in the chat window so user can see their page changes & restore if needed
     */
    function addPageHistoryToMessagesArea(history, insertAtTop = false) {
      const chatbotMessagesContainer = document.getElementById('chatbotMessagesContainer');
      
      // Create header section if it doesn't exist
      //let headerSection = document.getElementById('pageHistoryHeader');
      //if (!headerSection) {
      //  headerSection = document.createElement('div');
      //  headerSection.id = 'pageHistoryHeader';
      //  headerSection.className = 'mb-4 text-center font-bold text-lg';
      //  headerSection.textContent = 'Page Change History';
      //  chatbotMessagesContainer.appendChild(headerSection);
      //}

      const wrapper = document.createElement('div');
      wrapper.className = 'mb-4 flex items-start';

      // Timeline visualization
      const timeline = document.createElement('div');
      timeline.className = 'mr-4 flex flex-col items-center';
      
      const dot = document.createElement('div');
      dot.className = 'w-4 h-4 rounded-full bg-blue-500';
      
      const line = document.createElement('div');
      line.className = 'w-0.5 h-full bg-gray-300 -mt-2';
      
      timeline.appendChild(dot);
      timeline.appendChild(line);

      const contentWrapper = document.createElement('div');
      contentWrapper.className = 'flex-grow';

      const labelContainer = document.createElement('div');
      labelContainer.className = 'flex items-center mb-1';

      const timestamp = document.createElement('span');
      timestamp.className = 'text-xs text-gray-500 mr-2';
      timestamp.textContent = new Date(history.created_at).toLocaleString();

      const label = document.createElement('span');
      label.className = 'text-xs text-gray-700 font-semibold';
      label.textContent = 'Page Change:';

      // Create a container div for all buttons
      const buttonsContainer = document.createElement('div');
      buttonsContainer.className = 'flex ml-2';

      const viewButton = document.createElement('button');
      viewButton.className = 'text-blue-500 hover:text-blue-700 text-xs underline mr-2';
      viewButton.textContent = 'View';
      viewButton.onclick = function() {
        console.log('History item clicked:', history);
        const modal = document.getElementById('historyModal');
        const mainIframe = document.getElementById('mainIframe');
        mainIframe.innerHTML = atob(history.content);
        document.getElementById('userPrompt').innerHTML = history.user_message;
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        document
          .getElementById('restoreButton')
          .setAttribute('llama-data-web-page-history-id', history.id);
      };

      // Add buttons to the buttons container
      buttonsContainer.appendChild(viewButton);

      // Append elements to their containers
      labelContainer.appendChild(timestamp);
      labelContainer.appendChild(label);
      labelContainer.appendChild(buttonsContainer);

      contentWrapper.appendChild(labelContainer);

      const pageHistoryDiv = document.createElement('div');
      pageHistoryDiv.className = 'p-2 rounded bg-gray-100 text-sm';
      
      const prompt = history.prompt || history.user_message;
      
      // Function to check if string contains HTML
      function containsHTML(str) {
        const htmlRegex = /<[a-z][\s\S]*>/i;
        return htmlRegex.test(str);
      }

      // Render content based on whether it contains HTML
      if (containsHTML(prompt)) {
        // Create iframe for HTML content
        const iframe = document.createElement('iframe');
        iframe.style.width = '100%';
        iframe.style.border = 'none';
        iframe.style.height = '100px';
        iframe.style.maxWidth = '400px';
        iframe.style.maxHeight = '300px';
        iframe.style.overflow = 'auto';
        iframe.setAttribute('sandbox', 'allow-same-origin');

        iframe.srcdoc = prompt;
        
        pageHistoryDiv.innerHTML = '';
        pageHistoryDiv.appendChild(iframe);
        
        iframe.onload = () => {
          iframe.style.height = iframe.contentWindow.document.body.scrollHeight + 'px';
        };
      } else {
        // Regular text content
        pageHistoryDiv.textContent = `"${prompt}"`;
      }

      contentWrapper.appendChild(pageHistoryDiv);

      wrapper.appendChild(timeline);
      wrapper.appendChild(contentWrapper);

      // Change the insertion point based on whether we're loading older messages
      if (insertAtTop) {
        // Insert after the header for older messages
        chatbotMessagesContainer.insertBefore(wrapper, chatbotMessagesContainer.firstChild);
      } else {
        // Append to bottom for newest messages
        chatbotMessagesContainer.appendChild(wrapper);
      }

      if (!insertAtTop) {
        chatbotMessagesContainer.scrollTop = chatbotMessagesContainer.scrollHeight;
      }
    }

    document
      .getElementById("restoreButton")
      .addEventListener("click", function () {
        // Do a POST with the webPageHistory.id to /pages/restore
        let webPageId = "<%=@page&.id%>";
        // we save it to the restoreButton so that when the user clicks on the history item.. we have the ID.

        const webPageHistoryId = document
          .getElementById("restoreButton")
          .getAttribute("llama-data-web-page-history-id");

        fetch(
          `/pages/${webPageId}/restore.json?page_history_id=${webPageHistoryId}`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              web_page_history_id: webPageHistoryId,
            }),
          }
        )
          .then((response) => {
            if (response.ok) {
              return response.json();
            } else {
              throw new Error("Couldn't restore");
            }
          })
          .then((data) => {
            alert("Web page restored");
            console.log("Web page restored:", data);
            location.reload();
          });
      });

    /**
     * Return Summary of Prompt so user understand chat history better.
     * @param {string} prompt - The original prompt from the user.
     * @returns {string} - A summary of the prompt.
     */
    function summarizePrompt(prompt) {
      //if null, return empty string
      if (prompt == null) {
        return "";
      }
      // Split the text into sentences
      const sentences = prompt.split(".");

      // Take the first two sentences
      const firstTwo = sentences.slice(0, 2);

      // Join them back together and trim whitespace
      let summary = firstTwo.join(".").trim() + ".";

      // Truncate to a maximum of 50 words
      const words = summary.split(/\s+/);
      if (words.length > 50) {
        summary = words.slice(0, 50).join(" ") + "...";
      }

      return summary;
    }



    // Initial bot message
    loadChatHistory();

    const textarea = document.getElementById('userInput');
    const maxRows = 10; // Set this to your desired maximum number of rows

    function autoResizeUserInputArea() {
        textarea.style.height = 'auto';
        const newHeight = Math.min(textarea.scrollHeight, textarea.rows * 24 * maxRows);
        textarea.style.height = newHeight + 'px';
        //minimum make it 2 rows
        if (newHeight < 24) {
          textarea.style.height = '24px';
        }
    }

    textarea.addEventListener('input', autoResizeUserInputArea);
    let lastElementClicked = null;
    
    document.addEventListener('mousedown', function(e) {
      lastElementClicked = e.target;
      console.log("lastElementClicked in Javascript.js", lastElementClicked);
    });

    document.addEventListener('keydown', function(e) {
    // Check if Cmd+shift+L (Mac) or Ctrl+shift+L (Windows/Linux) is pressed to put content into chatbot container
      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'l') {
        e.preventDefault(); // Prevent default browser behavior
        
        //Get the current text selected by the cursor
        const selectedText = `\`\`\`${window.getSelection().toString()}\`\`\` \n`;
        //$("#chatbotContainer").show();
        if (!isOpen) {
            toggleChat();
        }
        
        $("#userInput").val(selectedText);
        $("#userInput").focus();
        autoResizeUserInputArea();
        inSelectionMode = true;
        handleElementSelection({target: lastElementClicked, preventDefault: function() {}, stopPropagation: function() {}});
      }
      else if (e.key == "Escape") { //toggle the chat window to open and close
        e.preventDefault();
        e.stopPropagation();
        toggleChat();
      }
      else if (e.key == "รง") { //selection mode -- this is option + c on mac
        e.preventDefault(); //prevent the รง key from being typed
        e.stopPropagation(); //prevent the รง key from being typed
        toggleSelectionMode();
      }
      else if ((e.metaKey || e.ctrlKey) && e.key == 's') { //save button -- this is cmd + s on mac
        e.preventDefault(); //prevent the s key from being typed
        e.stopPropagation(); //prevent the s key from being typed
        saveChanges();
      }
    });

    // Add keyboard shortcuts for undo/redo
    // document.addEventListener('keydown', function(e) {
    //   if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
    //     e.preventDefault();
    //     undoPageChange();
    //   } else if ((e.ctrlKey && e.shiftKey && e.key === 'Z') || (e.ctrlKey && e.key === 'y')) {
    //     e.preventDefault();
    //     redoPageChange();
    //   }
    // });

    function undoPageChange() {
      let webPageId = "<%=@page&.id%>";
      if (webPageId) {
        sessionStorage.setItem('showTimelineAfterReload', 'true');
        const token = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
        fetch(`/pages/${webPageId}/page_undo`, {
          method: 'POST',
          headers: {
            'X-CSRF-Token': token
          },
          credentials: 'same-origin'
        })
        .then(response => {
          console.log('Response: ')
          console.log(response)
          if (!response.ok) {
            console.log("Response Not Okay")
            if (response.status === 404) {
              throw new Error('Page not found');
            }
            
            return response.json().then(data => {
              console.log("ERROR throw")
              throw new Error(data.error || 'Failed to undo change');
            });
          }
          console.log("Returning response as response")
          return response;
        })
        .then(data => {
          console.log("Then ")
          if (data.error) {
            console.log("Showing Error notification")
            showNotification(data.error, 'error');
          } else {
            location.reload();
          }
        })
        .catch(error => {
          console.log("Here --")
          console.error('Error:', error);
          showNotification(error.message || 'Failed to undo change', 'error');
        });
      } else {
        showNotification('No page ID found', 'error');
      }
    }

    window.undoPageChange = undoPageChange;

    function redoPageChange() {
      let webPageId = "<%=@page&.id%>";
      if (webPageId) {
        sessionStorage.setItem('showTimelineAfterReload', 'true');
        fetch(`/pages/${webPageId}/page_redo`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': document.querySelector('[name="csrf-token"]')?.content
          }
        })
        .then(response => {
          if (!response.ok) {
            if (response.status === 404) {
              throw new Error('Page not found');
            }
            return response.then(data => {
              throw new Error(data.error || 'Failed to redo change');
            });
          }
          return response;
        })
        .then(data => {
          if (data.error) {
            showNotification(data.error, 'error');
          } else {
            location.reload();
          }
        })
        .catch(error => {
          console.error('Error:', error);
          showNotification(error.message || 'Failed to redo change', 'error');
        });
      } else {
        showNotification('No page ID found', 'error');
      }
    }

    window.redoPageChange = redoPageChange

    // Add this code at the end of the file
    document.addEventListener('DOMContentLoaded', function() {
      const feedbackModal = document.getElementById('feedbackModal');
      
      if (feedbackModal) {
        // Set non-editable attribute on the modal and all its children
        feedbackModal.setAttribute('data-llama', 'exclude_when_saving_contenteditable_edits');
        feedbackModal.querySelectorAll('*').forEach(el => {
          el.setAttribute('data-llama', 'exclude_when_saving_contenteditable_edits');
        });
        
        // Handle cancel button
        document.getElementById('cancelFeedback')?.addEventListener('click', function() {
          feedbackModal.classList.remove('flex');
          feedbackModal.classList.add('hidden');
          // Reset current reaction
          currentReaction = { messageId: null, type: null, button: null };
        });
        
        // Handle submit button
        document.getElementById('submitFeedback')?.addEventListener('click', function() {
          const feedback = document.getElementById('feedbackText').value;
          submitReaction(
            currentReaction.messageId, 
            currentReaction.type, 
            currentReaction.button, 
            feedback
          );
          feedbackModal.classList.remove('flex');
          feedbackModal.classList.add('hidden');
        });
      }
    });
  });

  document.addEventListener("DOMContentLoaded", () => {
    const menuToggle = document.getElementById("menu-toggle");
    const mobileMenu = document.getElementById("mobile-menu");

    menuToggle?.addEventListener("click", () => {
      mobileMenu.classList.toggle("hidden");
    });
  });

  var inSelectionMode = false;
  let selectedElementHTML = null;

  function getIsInSelectionMode(){ //needed for tutorial to check if we're in selection mode
    return inSelectionMode;
  }
  window.getIsInSelectionMode = getIsInSelectionMode;

  /**
   * Toggle selection mode. This allows the user to select an element on the page that they want the LLM to edit.
   */
  function toggleSelectionMode() {
    inSelectionMode = !inSelectionMode;
    window.llamaElementInspector.toggleInspector(inSelectionMode);
    
    const chatbotContainer = document.getElementById("chatbotContainer");
    const sidePanelButtons = document.querySelectorAll('#llama-side-panel button');
    const menuTrigger = document.getElementById('llama-menu-trigger');
    const selectionExit = document.getElementById('llama-selection-exit');
    const panel = document.getElementById('llama-side-panel');
    
    if (inSelectionMode) {
      // Hide side panel buttons except selection exit
      sidePanelButtons.forEach(button => {
        if (button.id !== 'llama-selection-exit') {
          button.style.display = 'none';
        }
      });
      
      // Hide menu trigger, show selection exit
      menuTrigger.classList.add('hidden');
      selectionExit.classList.remove('hidden');
      
      // Add click handler for selection exit
      selectionExit.onclick = () => toggleSelectionMode();
      
      // Make sure panel is closed in selection mode
      panel.classList.add('-translate-x-full');
      
      document.body.classList.add("selection-mode");
      document.getElementById("llama-bot-message-to-user").textContent = "Select an element you want to edit!";
      document.getElementById("llama-bot-message-to-user").classList.add("animate-pulse");
      chatbotContainer.classList.add("hidden");
      
      document.addEventListener('keydown', handleSelectionModeEscape);
    } else {
      // Show all side panel buttons except selection exit
      sidePanelButtons.forEach(button => {
        if (button.id !== 'llama-selection-exit') {
          button.style.display = '';
        }
      });
      
      // Show menu trigger, hide selection exit
      menuTrigger.classList.remove('hidden');
      selectionExit.classList.add('hidden');
      
      document.getElementById("llama-bot-message-to-user").classList.remove("animate-pulse");
      document.getElementById("llama-bot-message-to-user").textContent = "What do you want to change?";
      document.body.classList.remove("selection-mode");
      chatbotContainer.classList.remove("hidden");
      
      document.removeEventListener('keydown', handleSelectionModeEscape);
    }

    console.log("Selection mode:", inSelectionMode ? "ON" : "OFF");
  }

  // Add this new function to handle escape key
  function handleSelectionModeEscape(e) {
    if (e.key === "Escape" && inSelectionMode) {
      toggleSelectionMode();
    }
  }

  /**
   * Handle element selection. This fires when the user to selects an element on the page that they want the LLM to edit.
   * @param {Event} event - The event object.
   */
  function handleElementSelection(event) {
    console.log("Handle Element Selection called");
    console.log("inSelectionMode", inSelectionMode);
    if (!inSelectionMode) return; //prevent from running if selection mode is off

    // Check if clicked element or its parent has the ignore class
    if (event.target.closest('.llama-inspector-ignore')) {
        // Don't prevent default or stop propagation for ignored elements
        return; // Exit early without selecting the element
    }

    event.preventDefault();
    event.stopPropagation();

    const selectedElement = event.target;
    console.log("Selected element:", selectedElement);

    // Remove the selection class from any previously selected element
    const previouslySelected = document.querySelector(".selected-element");
    if (previouslySelected) {
        previouslySelected.classList.remove("selected-element");
    }

    // Add selection class to the newly selected element
    selectedElement.classList.add("selected-element");

    // Here you can do whatever you want with the selected element
    window.lastSelectedElement = selectedElement;

    // Trigger a custom event
    const customEvent = new CustomEvent("elementSelected", {
        detail: selectedElement,
    });
    document.dispatchEvent(customEvent);

    // Turn off selection mode after selecting an element
    toggleSelectionMode();
  }

  // Add necessary event listeners
  document.addEventListener("click", handleElementSelection, true);

  // Listen for custom elementSelected event
  document.addEventListener("elementSelected", (e) => {
    hideAllChatToolWindows(); //close all chat tool windows to make room for selected element
    selectedElementHTML = e.detail;

    let selectedElementContainer = document.getElementById(
      "selectedElementContainer"
    );
    let selectedElementContent = document.getElementById(
      "selectedElementContent"
    );
    if (selectedElementHTML != null && selectedElementContainer != null) {
      //TODO: There is a bug if there's chat history that contains selected element in it and it's rendering the HTML in the chat history.
      selectedElementContainer.style.display = "block";
      selectedElementContent.innerHTML = selectedElementHTML.outerHTML;
      setSelectedElementContainerBackground(selectedElementHTML);
    }

    console.log("Element selected event:", selectedElementHTML);
  });

  // Add this to the end of the script
  document
    .getElementById("closeSelectedElement")
    .addEventListener("click", function () {
      console.log("Selected element closed");
      document.getElementById("selectedElementContainer").style.display =
        "none";
      document.getElementById("selectedElementContent").innerHTML = "";
      // remove selected-element class any other elements
      document.querySelectorAll(".selected-element").forEach(element => {
        element.classList.remove("selected-element");
      }); 
    });

  let isExpanded = false;
  const chatbotContainer = document.getElementById("chatbotContainer");
  const expandButton = document.getElementById("expandButton");

  /**
   * Sets the default expanded size of the chatbot.
   */
  function setExpandedSize() {
    isExpanded = true;
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;

    if (screenWidth < 768) {
      // Mobile devices
      chatbotContainer.style.width = "80%";
      chatbotContainer.style.height = "90%";
      chatbotContainer.style.maxWidth = "none";
      chatbotContainer.style.maxHeight = "none";
    } else if (screenWidth < 1024) {
      // Tablets
      chatbotContainer.style.maxWidth = "600px";
      chatbotContainer.style.maxHeight = "800px";
    } else {
      // Desktops
      chatbotContainer.style.width = "800px";
      chatbotContainer.style.height = "800px";
    }
  }

  /**
   * Sets the default collapsed size of the chatbot.
   */
  function setCollapsedSize() {
    isExpanded = false;
    const screenWidth = window.innerWidth;

    if (screenWidth < 768) {
      // Mobile devices
      chatbotContainer.style.width = "100%";
      chatbotContainer.style.height = "50%";
    } else {
      chatbotContainer.style.width = "480px";
      chatbotContainer.style.height = "576px";
    }
  }

  /**
   * Toggle the chatbot size between expanded and collapsed. This fires when user clicks on the top right expand button.
   */
  function toggleExpand() {
    if (isExpanded) {
      setCollapsedSize();
    } else {
      setExpandedSize();
    }
  }

  // Call this function initially and on window resize
  function updateChatbotSize() {
    if (isExpanded) {
      setExpandedSize();
    } else {
      setCollapsedSize();
    }
  }

  // Add event listeners
  expandButton.addEventListener("click", toggleExpand);
  window.addEventListener("resize", updateChatbotSize);

  // Initial setup
  document.addEventListener("DOMContentLoaded", () => {
    setCollapsedSize(); // Start with collapsed size
  });

  // Add this function to the end of the script
  function setSelectedElementContainerBackground(selectedElement) {
    const container = document.getElementById("selectedElementContainer");
    const content = document.getElementById("selectedElementContent");

    // Get the background color of the parent element
    let bgColor = window.getComputedStyle(
      selectedElement.parentElement
    ).backgroundColor;

    // If the background is transparent, try to find the nearest parent with a background
    let parent = selectedElement.parentElement;
    while (bgColor === "rgba(0, 0, 0, 0)" && parent.parentElement) {
      parent = parent.parentElement;
      bgColor = window.getComputedStyle(parent).backgroundColor;
    }

    // Set the background color of the container
    container.style.backgroundColor = bgColor;

    // Adjust text color for better contrast
    const rgb = bgColor.match(/\d+/g);
    if (rgb) {
      const brightness =
        (parseInt(rgb[0]) * 299 +
          parseInt(rgb[1]) * 587 +
          parseInt(rgb[2]) * 114) /
        1000;
      content.style.color = brightness > 125 ? "black" : "white";
    }
  }

  function toggleDebugContainer() {
    const debugContainer = document.getElementById('debugContainer');
    const relevantErrorsList = document.getElementById('relevantErrorsList');
    //debugger;
    //debugContainer.classList.toggle('hidden');
    //relevantErrorsList.classList.toggle('hidden');

    if (debugContainer.classList.contains('hidden')) {
        debugContainer.classList.remove('hidden');
    } else {
        debugContainer.classList.add('hidden');
    }
    relevantErrorsList.innerHTML = '';
    for (const error of uncaughtErrors) {
      relevantErrorsList.innerHTML += `<li class="text-sm text-red-600">${error.message}</li>`;
    }
    

  }

  // Function to update the debug badge count
  function updateDebugBadge(count) {
      const badge = document.getElementById('debugBadge');
      if (count > 0) {
          badge.textContent = count > 99 ? '99+' : count;
          badge.classList.remove('hidden');
      } else {
          badge.classList.add('hidden');
      }
  }

  // Function to increment the debug badge
  function incrementDebugBadge() {
      const badge = document.getElementById('debugBadge');
      const currentCount = parseInt(badge.textContent) || 0;
      updateDebugBadge(currentCount + 1);
  }

  // Function to clear the debug badge
  function clearDebugBadge() {
      updateDebugBadge(0);
  }

  // Add this near the end of the script
  document.addEventListener("DOMContentLoaded", () => {
    const toggleImagesButton = document.getElementById(
      "toggleImagesForUserToSelect"
    );
    const imagesContainer = document.getElementById("imagesForUserToSelect");

    // Initially hide the images container
    imagesContainer.style.display = "none";

    toggleImagesButton.addEventListener("click", () => {
      if (imagesContainer.style.display === "none") {
        document.querySelectorAll('.llama-chat-toolbar-window').forEach(window => {
          window.style.display = 'none';
        });
        imagesContainer.style.display = "block";
      } else {
        imagesContainer.style.display = "none";
      }
    });
  });
</script>










