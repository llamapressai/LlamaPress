<script>
  let chatChannel;
  let sessionId; // Global sessionId variable
  console.log("Loaded...");

  let isLoading = false;
  let lastPongTime = Date.now() - 30000;
  let connectionCheckInterval;
  let redStatusStartTime = null;
  let errorModalShown = false;

  // Create error modal element
  const errorModal = document.createElement('div');
  errorModal.innerHTML = `
    <div id="connectionErrorModal" class="hidden fixed inset-0 z-50 overflow-auto bg-red-100 bg-opacity-90 flex">
      <div class="relative p-8 bg-white w-full max-w-md m-auto flex-col flex rounded-lg border-4 border-red-500">
        <div class="text-red-500 text-2xl font-bold mb-4">Connection Error</div>
        <div class="text-red-700 mb-4">
          Unable to establish connection to LlamaBot. Please try:
          <ul class="list-disc ml-4 mt-2">
            <li>Refreshing the page</li>
            <li>Checking your internet connection</li>
            <li>Trying again in a few minutes</li>
          </ul>
        </div>
        <button onclick="window.location.reload()" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">
          Refresh Page
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(errorModal);

  function showErrorModal() {
    if (!errorModalShown) {
      const modal = document.getElementById('connectionErrorModal');
      modal.classList.remove('hidden');
      errorModalShown = true;
    }
  }

  function hideErrorModal() {
    const modal = document.getElementById('connectionErrorModal');
    modal.classList.add('hidden');
    errorModalShown = false;
  }


  const GREEN_CONNECTED_STATUS_COLOR = 'bg-green-500';
  const YELLOW_CONNECTED_STATUS_COLOR = 'bg-yellow-400';
  const RED_CONNECTED_STATUS_COLOR = 'bg-red-500';

  // Add this function to update the status indicator
  function updateConnectionStatus() {
    const timeSinceLastPong = Date.now() - lastPongTime;
    
    if (timeSinceLastPong < 30000) { // Less than 30 seconds
      updateStatusIcon(GREEN_CONNECTED_STATUS_COLOR);
      redStatusStartTime = null;
      errorModalShown = false;
    } else if (timeSinceLastPong < 50000) { // Between 30-50 seconds
      updateStatusIcon(YELLOW_CONNECTED_STATUS_COLOR);
      redStatusStartTime = null;
      errorModalShown = false;
    } else { // More than 50 seconds
      updateStatusIcon(RED_CONNECTED_STATUS_COLOR);
      if (!redStatusStartTime) {
        redStatusStartTime = Date.now();
      } else if (Date.now() - redStatusStartTime > 5000 && !errorModalShown) { // 5 seconds in red status
        showErrorModal();
      }
    }
  }

  // Update the status icon with the given color
  function updateStatusIcon(color) {
    const statusIndicator = document.getElementById('connectionStatusIconForLlamaBot');
    statusIndicator.classList.remove(YELLOW_CONNECTED_STATUS_COLOR, RED_CONNECTED_STATUS_COLOR, GREEN_CONNECTED_STATUS_COLOR);  // Remove all existing classes
    statusIndicator.classList.add(color);
  }

  // Get chat_message from URL param if present
  function getQueryParam(name) {
    const url = new URL(window.location.href);
    return url.searchParams.get(name);
  }


  function handleChatUrlParams() {
    // Check if a chat message exists in the Rails flash

    // Fallback to flash if param is not present
    const chatMessage =
      getQueryParam('chat_message') ||
      <%= raw (flash[:chat_message] || "").to_json %>;

    if (chatMessage) {
      // Show chat container if it's hidden
      const chatbotContainer = document.getElementById('chatbotContainer');
      if (chatbotContainer.classList.contains('hidden')) {
        chatbotContainer.classList.remove('hidden');
      }
      
      // Set the message in the input
      const userInput = document.getElementById('userInput');
      userInput.value = chatMessage;
      
      // Automatically send the message
      setTimeout(() => {
        const sendButton = document.getElementById('sendButton');
        sendButton.click();
      }, 1000); // Small delay to ensure everything is loaded
    }
  }

  /**
   * Initialize the chat channel (ActionCable). This allows us to send and receive messages to LlamaBot Backend.
   */
  function initializeChat() {
    if (chatChannel) {
        console.log("ChatChannel already initialized.");
        return;
    }
    
    console.log("Initializing Chat...");
    
    const consumer = ActionCable.createConsumer();
    connectionCheckInterval = setInterval(updateConnectionStatus, 1000);

    sessionId = "<%= @page&.id || 1 %>"; // This groups our convo message history by page id automatically using by relying on langgraph's psql checkpointer

    let htmlFragmentBuffer = ''; // to save when HTML doc is getting streamed back to us.
    let fullMessageBuffer = ''; // Save this entirely for accurate parsing.
    let htmlChunksStartedStreaming = false;
    let htmlChunksEndedStreaming = false;

    let currentCodeExplanationFromLLM = '';
    let codeExplanationStartedStreaming = false;
    let codeExplanationEndedStreaming = false;
    let lastProcessedExplanationIndex = -1; // Track the last explanation we processed
    let completedExplanations = []; // Store all completed explanations
      
      // This is a placeholder example of how to route to a different Agent State Builder based on current page we're viewing. Google Ads Agent isn't available in OSS yet, reach out to Kody if you want access.
    <%# if request&.path&.include?("ads_dashboard") || request&.path&.include?("keywords") %>
      <%# agent_state_builder = "AdsAgentStateBuilder" %>
    <%# else %>
      <%# agent_state_builder = nil %>
    <%# end %>

    // Initialize ActionCable Consumer (this is the channel we're subscribing to in chat_channel.rb)
      chatChannel = consumer.subscriptions.create({channel: 'LlamaBotRails::ChatChannel', session_id: sessionId, agent_state_builder_class: "<%= defined?(agent_state_builder) ? agent_state_builder : nil %>"},
      {
        /**
         * Receives message responses from LlamaBot Backend.
         */
        received(data) {
          //console.log("Received response from LlamaBot Backend:", data);
          //console.log("Data type:", typeof data);

          try {
            // Parse the incoming data - simplify the parsing chain
            let parsed;
            if (typeof data === 'string') {
              parsed = JSON.parse(data);
            } else {
              parsed = data;
            }
            
            //console.log("Parsed data:", parsed);

            // Handle pong messages that might be objects
            if (parsed.message && typeof parsed.message === 'object' && (parsed.message.type === "external_ws_pong" || parsed.message.type === "pong")) {
              lastPongTime = Date.now(); // Update last pong time, which will keep the status icon green
              return;
            }

            let parsedData;
            if (typeof parsed.message === 'string') {
              parsedData = JSON.parse(parsed.message);
            } else {
              parsedData = parsed.message;
            }
            
            //console.log("Parsed message data:", parsedData);

            // This will run regardless of success or failure
            
            // Reset send button state
            const sendButton = document.getElementById('sendButton');
            sendButton.textContent = 'Send';
            sendButton.classList.remove('bg-red-500', 'hover:bg-red-600');
            sendButton.classList.add('bg-blue-500', 'hover:bg-blue-600');

            if (parsedData.content === 'Workflow completed') {
              window.location.reload();
              return;
            }
            
            switch (parsedData.type) {
              case 'ai_message':
              case 'ai': // New gem format
                // Finish any streaming message when we get a complete AI message
                finishStreamingMessage();

                //TODO: This is a hacky way to format our message to add a brain for tool-calling. We need to refactor this.
                // We need to DRY up this code somehow by making the formatting be handled in a single place. 
                // Right now, similar logic is happening in multiple places: _websocket.html.erb, _core_javascript.html.erb, chat_channel.rb, and pages_controller.rb.
                if (!parsedData.content) {
                  if(parsedData.additional_kwargs && "tool_calls" in parsedData.additional_kwargs){
                    //sorry for using this quick & dirty way to titleize the tool name.
                    let titleized_tool_name = parsedData.additional_kwargs["tool_calls"][0]["function"]["name"].replace( //https://stackoverflow.com/questions/196972/convert-string-to-title-case-with-javascript
                        /\w\S*/g,
                        text => text.charAt(0).toUpperCase() + text.substring(1).toLowerCase()
                      );

                    parsedData.content = "üß†: " + titleized_tool_name + " called with arguments: " + parsedData.additional_kwargs["tool_calls"][0]["function"]["arguments"]
                  }
                  else if (parsedData.base_message && parsedData.base_message.tool_calls && parsedData.base_message.tool_calls.length > 0){
                    //tool call following this format.
                    // This is the format of most tool calls now going forward. (LlamaBot standard)
                      //parsedData.base_message.tool_calls[0]
                      //{name: 'clone_image_tool', args: {‚Ä¶}, id: 'call_HO9yh30WUS1upFw0K1FgavZs', type: 'tool_call'}args: image_url: "https://llamapress-ai-image-uploads.s3.us-west-2.amazonaws.com/dfyabudvss9or33cwgc6pw6q5x54"[[Prototype]]: Objectid: "call_HO9yh30WUS1upFw0K1FgavZs"name: "clone_image_tool"type: "tool_call"[[Prototype]]: Object
                      if (parsedData.base_message.tool_calls[0].name == "clone_image_tool"){
                        parsedData.content = "üîç I'm looking at your image now! This might take a minute or two..."
                      }
                  }
                }
                else { //return early -- since we're listening to AIMessageChunks, we don't want to add this ai message to the chat if it's not a tool call.
                  isLoading = false;
                  hideLoadingIndicator();
                  break;
                }

                const messageElement = addMessage(parsedData.content, "ai");
                
                // Store trace info if available
                if (parsedData.langsmith_trace) {
                  // Generate a unique ID for this message if it doesn't have one already
                  const messageId = messageElement.getAttribute('data-message-id') || 
                                   `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
                  
                  if (!messageElement.hasAttribute('data-message-id')) {
                    messageElement.setAttribute('data-message-id', messageId);
                  }
                  
                  // Store trace info for this message
                  window.messageTraces[messageId] = parsedData.langsmith_trace;
                  console.log(`Stored trace info for message ${messageId}:`, parsedData.langsmith_trace);
                  

                }
                break;
              case 'tool': // New gem format for tool messages
                finishStreamingMessage();
                addMessage(parsedData.content, "tool");
                break;
              case 'system_message':
                finishStreamingMessage();
                addMessage(parsedData.content, "system");
                break;
              case 'think_message':
                finishStreamingMessage();
                addMessage(parsedData.content, "system");
                break;
              case 'fragment_from_html_stream_message':
                handleFragment(parsedData.content);
                break;
              case 'user_input_required':
                addMessage(parsedData.content, "bot");
                break;
              case 'write_code':
                addMessage("Received changes. Writing to the file system...", "system");
                window.location.reload();
                break;
              case 'external_ws_pong':
              case 'pong': // New gem format
                lastPongTime = Date.now();
                //console.log("Received pong response from LlamaBot Backend, which means we're connected");
                break;
              case 'error':
                addMessage(parsedData.content, "error");
                break;
              case 'AIMessageChunk':
                if (parsedData.content == '' || parsedData.content == null) { // if the parsedData.content is empty or null, it means we're likely getting a tool call chunk back.
                  //tool call.?
                  if (parsedData.base_message.tool_call_chunks == undefined) {
                    break;
                  }

                  let tool_call_data = parsedData.base_message.tool_call_chunks[0].args; //get tool call data.

                  htmlFragmentBuffer += tool_call_data;
                  fullMessageBuffer += tool_call_data;
                  
                    if (codeExplanationStartedStreaming) {
                     
                     // Handle case where opening tag might be in this chunk
                     let chunkToProcess = tool_call_data;
                     let openingTagIndex = chunkToProcess.indexOf('<code_explanation>');
                     if (openingTagIndex !== -1) {
                       // Opening tag is in this chunk, skip everything before and including the tag
                       chunkToProcess = chunkToProcess.substring(openingTagIndex + 18);
                     }
                     
                     // Check for multiple possible closing tag formats (escaped and unescaped)
                     let closingTagIndex = -1;
                     let closingTagLength = 0;
                     
                     // Try different closing tag formats
                     const closingTags = ['</code_explanation>', '<\\/code_explanation>', '&lt;/code_explanation&gt;'];
                     for (let tag of closingTags) {
                       let index = chunkToProcess.indexOf(tag);
                       if (index !== -1) {
                         closingTagIndex = index;
                         closingTagLength = tag.length;
                         break;
                       }
                     }
                     
                     if (closingTagIndex != -1) {
                       // Found closing tag in this chunk - add only the part before it
                       let finalPart = chunkToProcess.substring(0, closingTagIndex);
                       currentCodeExplanationFromLLM += finalPart;
                       
                       // Mark as complete
                       codeExplanationEndedStreaming = true;
                       codeExplanationStartedStreaming = false;
                       
                       // Add to completed explanations history
                       completedExplanations.push(currentCodeExplanationFromLLM);
                       
                       // Update global variable with final content
                       window.currentCodeExplanationFromLLM = currentCodeExplanationFromLLM;
                       window.completedExplanations = completedExplanations;
                       console.log("Code explanation:", JSON.stringify(currentCodeExplanationFromLLM));
                       // Final update to explanation display
                       if (window.terminalMode === 'explanation') {
                         updateExplanationDisplay();
                       }
                       currentCodeExplanationFromLLM = "";
                     } else {
                       // Check if closing tag is already in our accumulated content
                       let accumulatedContent = currentCodeExplanationFromLLM + chunkToProcess;
                       for (let tag of closingTags) {
                         let index = accumulatedContent.indexOf(tag);
                         if (index !== -1) {
                           currentCodeExplanationFromLLM = accumulatedContent.substring(0, index);
                           
                           // Add to completed explanations history
                           completedExplanations.push(currentCodeExplanationFromLLM);
                           
                           codeExplanationEndedStreaming = true;
                           codeExplanationStartedStreaming = false;
                           window.currentCodeExplanationFromLLM = currentCodeExplanationFromLLM;
                           window.completedExplanations = completedExplanations;
                           if (window.terminalMode === 'explanation') {
                             updateExplanationDisplay();
                           }
                           currentCodeExplanationFromLLM = "";
                           return;
                         }
                       }
                       
                       // No closing tag yet, add the whole processed chunk
                       currentCodeExplanationFromLLM += chunkToProcess;
                       
                       // Update the global variable and refresh explanation display
                       window.currentCodeExplanationFromLLM = currentCodeExplanationFromLLM;
                       
                       if (window.terminalMode === 'explanation') {
                         updateExplanationDisplay();
                       }
                     }
                   }
                  
                                     // Check if we should start processing code_explanation content
                   // Find the LAST occurrence of the opening tag to handle multiple explanations
                   let codeExplanationTagIndex = fullMessageBuffer.lastIndexOf('<code_explanation>');
                   if (codeExplanationTagIndex != -1 && !codeExplanationStartedStreaming && codeExplanationTagIndex > lastProcessedExplanationIndex) {
                     // Count how many explanation tags are in the buffer
                     let tagCount = (fullMessageBuffer.match(/<code_explanation>/g) || []).length;
                     
                     // Update the last processed index
                     lastProcessedExplanationIndex = codeExplanationTagIndex;
                     
                     // Reset flags for new explanation cycle
                     codeExplanationEndedStreaming = false;
                     codeExplanationStartedStreaming = false;
                     
                     // Check if the complete explanation is already in the buffer
                     let contentAfterOpeningTag = fullMessageBuffer.substring(codeExplanationTagIndex + 18);
                     
                     // Look for various closing tag formats
                     const closingTags = ['</code_explanation>', '<\\/code_explanation>', '&lt;/code_explanation&gt;'];
                     let closingTagIndex = -1;
                     let foundClosingTag = '';
                     
                     for (let tag of closingTags) {
                       let index = contentAfterOpeningTag.indexOf(tag);
                       if (index !== -1) {
                         closingTagIndex = index;
                         foundClosingTag = tag;
                         break;
                       }
                     }
                     
                     if (closingTagIndex !== -1) {
                       // Complete explanation is available right now
                       currentCodeExplanationFromLLM = contentAfterOpeningTag.substring(0, closingTagIndex);
                       
                       // Add to completed explanations history
                       completedExplanations.push(currentCodeExplanationFromLLM);
                       
                       window.currentCodeExplanationFromLLM = currentCodeExplanationFromLLM;
                       window.completedExplanations = completedExplanations;
                       codeExplanationEndedStreaming = true;
                       // Don't set codeExplanationStartedStreaming = true since we're already done
                       
                       if (window.terminalMode === 'explanation') {
                         updateExplanationDisplay();
                       }
                     } else {
                       // Only partial content, start streaming mode
                       codeExplanationStartedStreaming = true;
                       currentCodeExplanationFromLLM = '';
                     }
                   }

                  //search for <!doctype in the htmlFragmentBuffer
                  let htmlTagIndex = htmlFragmentBuffer.indexOf('<html');
                  if (htmlTagIndex != -1) {
                    htmlChunksStartedStreaming = true;
                    htmlFragmentBuffer = htmlFragmentBuffer.substring(htmlTagIndex); // remove everything before the <!doctype
                    //handleFragment(htmlFragmentBuffer);
                    //console.log("htmlFragmentBuffer:", htmlFragmentBuffer); 
                    //htmlFragmentBuffer = '';
                  }

                  let endingHtmlTagIndex = fullMessageBuffer.indexOf('</html>');
                  if (endingHtmlTagIndex != -1) {
                    htmlChunksEndedStreaming = true;
                    
                    // Add completion message to terminal based on mode
                    if (window.terminalMode === 'raw') {
                      const terminalContent = document.getElementById('terminalContent');
                      const cursor = document.getElementById('terminalCursor');
                      if (terminalContent && cursor) {
                        cursor.remove();
                        const completionText = '\n\n> HTML generation complete!\n> Ready for preview\n';
                        terminalContent.appendChild(document.createTextNode(completionText));
                        terminalContent.appendChild(cursor);
                      }
                    } else {
                      // In explanation mode, update to completion state
                      window.currentCodeExplanationFromLLM = 'HTML generation complete! Your page is ready for preview.';
                      updateExplanationDisplay();
                      
                      // Stop dots animation
                      if (window.dotsInterval) {
                        clearInterval(window.dotsInterval);
                      }
                    }
                    
                    // Safely handle modal cleanup
                    const modal = document.getElementById('fragmentModal');
                    if (modal) {
                      let finishedHtml = modal.htmlBuffer || '';
                      modal.remove();
                    }
                    // addMessage("Generated Page: " + `\`\`\`html ${finishedHtml} \`\`\``, "system");
                    // debugger;
                    // window.location.reload();
                    //fullMessageBuffer = fullMessageBuffer.substring(0, endingHtmlTagIndex + 7); // remove everything after the </html>
                    //handleFragment(fullMessageBuffer);
                    //console.log("fullMessageBuffer:", fullMessageBuffer); 

                    //htmlFragmentBuffer = '';
                  }

                  if (htmlChunksStartedStreaming && !htmlChunksEndedStreaming) {
                    // Handle both \\n (double escaped) and literal \n in the string
                    let cleanedFragment = htmlFragmentBuffer
                      .replace(/\\n/g, '\n')  // Convert \n to actual newlines
                      .replace(/\\"/g, '"')   // Convert \" to actual quotes
                      .replace(/\\t/g, '\t'); // Convert \t to actual tabs
                    handleFragment(cleanedFragment);
                    htmlFragmentBuffer = ''; // clear buffer for next chunk.
                  }
                }
                else {
                  addMessage(parsedData.content, "AIMessageChunk");
                }
                break;
              default:
                // Finish any streaming message when we get a different message type
                finishStreamingMessage();
                console.warn("Unknown message type:", parsedData.type);
                addMessage(`Unknown message type: ${parsedData.type}`, "system");
            }
          } catch (error) {
            console.error("Error parsing or processing received data:", error);
            addMessage(`Error: ${error.message}`, "error");
                        // This will run regardless of success or failure
            isLoading = false;

            hideLoadingIndicator();
            // Reset send button state
            const sendButton = document.getElementById('sendButton');
            sendButton.textContent = 'Send';

            //Remove 'Cancel' Button Red Background Color
            sendButton.classList.remove('bg-red-500', 'hover:bg-red-600');

            //Set the Blue button for the 'Send'
            sendButton.classList.add('bg-blue-500', 'hover:bg-blue-600');
          }
        },

        connected() {
          console.log("Connected to ChatChannel");
          // You can add any initialization code here
        },

    disconnected() {
      console.log("Disconnected from ChatChannel. Attempting to reconnect...");
      clearInterval(connectionCheckInterval);
      setTimeout(() => consumer.connection.reopen(), 5000);
    },

    rejected() {
      console.log("Connection to ChatChannel rejected");
      // Add exponential backoff retry logic
      const maxRetries = 5;
      let retryCount = 0;
      
      const retry = () => {
        if (retryCount < maxRetries) {
          const backoffTime = Math.min(1000 * Math.pow(2, retryCount), 30000); // Cap at 30 seconds
          console.log(`Retrying connection in ${backoffTime/1000} seconds... (Attempt ${retryCount + 1}/${maxRetries})`);
          
          setTimeout(() => {
            retryCount++;
            consumer.connection.reopen();
          }, backoffTime);
        } else {
          console.log("Max retry attempts reached. Please refresh the page to try again.");
          addMessage("Connection failed. Please refresh the page to try again.", "system");
        }
      };
      
      retry();
    }
  }
);


// const idleTimeout = 5 * 60 * 1000; // 5 minutes
//     let lastActivity = Date.now();

//     document.addEventListener('mousemove', () => lastActivity = Date.now());
//     document.addEventListener('keypress', () => lastActivity = Date.now());

//     setInterval(() => {
//       if (Date.now() - lastActivity > idleTimeout && !consumer.connection.isOpen()) {
//         console.log("User idle for too long, attempting reconnection...");
//         consumer.connection.reopen();
//       }
//     }, 5000); // Check every 5 seconds
  

document.addEventListener("visibilitychange", function() {
  if (document.visibilityState === 'visible' && !consumer.connection.isOpen()) {
      console.log("Tab is active. Reconnecting...");
      consumer.connection.reopen();
  }
});



console.log("ChatChannel created:", chatChannel); // Add this line
}

    const textarea = document.getElementById('userInput');
    const maxRows = 10; // Set this to your desired maximum number of rows



    let isOpen = false;
    let messages = [];

    function makeLoadingSpinner() {
      const spinner = document.createElement("div");
      spinner.innerHTML = `
        <div class="grid grid-cols-[40px_auto] gap-4 items-center w-full">
        <div class="grid min-h-[20px] w-full place-items-center overflow-x-scroll rounded-lg p-6 lg:overflow-visible">
        <svg class="text-gray-300 animate-spin" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg"
            width="24" height="24">
            <path
            d="M32 3C35.8083 3 39.5794 3.75011 43.0978 5.20749C46.6163 6.66488 49.8132 8.80101 52.5061 11.4939C55.199 14.1868 57.3351 17.3837 58.7925 20.9022C60.2499 24.4206 61 28.1917 61 32C61 35.8083 60.2499 39.5794 58.7925 43.0978C57.3351 46.6163 55.199 49.8132 52.5061 52.5061C49.8132 55.199 46.6163 57.3351 43.0978 58.7925C39.5794 60.2499 35.8083 61 32 61C28.1917 61 24.4206 60.2499 20.9022 58.7925C17.3837 57.3351 14.1868 55.199 11.4939 52.5061C8.801 49.8132 6.66487 46.6163 5.20749 43.0978C3.7501 39.5794 3 35.8083 3 32C3 28.1917 3.75011 24.4206 5.2075 20.9022C6.66489 17.3837 8.80101 14.1868 11.4939 11.4939C14.1868 8.80099 17.3838 6.66487 20.9022 5.20749C24.4206 3.7501 28.1917 3 32 3L32 3Z"
            stroke="currentColor" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"></path>
            <path
            d="M32 3C36.5778 3 41.0906 4.08374 45.1692 6.16256C49.2477 8.24138 52.7762 11.2562 55.466 14.9605C58.1558 18.6647 59.9304 22.9531 60.6448 27.4748C61.3591 31.9965 60.9928 36.6232 59.5759 40.9762"
            stroke="currentColor" stroke-width="5" stroke-linecap="round" stroke-linejoin="round" class="text-gray-900">
            </path>
        </svg>
        </div>
        <span class="thinking-pulse">Thinking... (this may take a while)</span>
        </div>`.trim();
      return spinner.firstElementChild;
    }

    function toggleChat() {
      isOpen = !isOpen;
      chatbotContainer.classList.toggle("hidden", !isOpen);
    }

    function openPreview() {
      const currentUrl = window.location.href;
      const queryIndex = currentUrl.indexOf('?');
      const hashIndex = currentUrl.indexOf('#');

      let splitIndex = -1;
      if (queryIndex !== -1 && hashIndex !== -1) {
        splitIndex = Math.min(queryIndex, hashIndex);
      } else if (queryIndex !== -1) {
        splitIndex = queryIndex;
      } else if (hashIndex !== -1) {
        splitIndex = hashIndex;
      }

      const baseUrl = splitIndex !== -1 ? currentUrl.substring(0, splitIndex) : currentUrl;
      const restOfUrl = splitIndex !== -1 ? currentUrl.substring(splitIndex) : '';

      const cleanBaseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;

      const newUrl = `${cleanBaseUrl}/preview${restOfUrl}`;

      window.open(newUrl, '_blank');
      window.location.reload();
    }

    // Global variable to track the current streaming message
    let currentStreamingMessage = null;
    let streamingMessageBuffer = '';

    function addMessage(text, sender) {
      if (sender != "AIMessageChunk") { //AIMessageChunk is a special case, it's not a message, it's a chunk of a message.
        const messageDiv = document.createElement("div");
        messageDiv.className = `p-2 rounded ${
          sender === "bot" || sender === "ai_message" ? "bg-blue-100" : 
          sender === "user" ? "bg-green-100" : 
          sender === "error" ? "bg-red-100" : 
          sender === "system" ? "bg-gray-100 border border-gray-200 text-xs text-gray-600 px-3 py-1" : 
          sender === "tool" || sender === "ai" ? "bg-gray-50 border border-gray-200 text-xs text-gray-600 px-3 py-1" : 
          "bg-gray-100"
        }`;

        // The below code is important for visual display (dependent on the tool name and arguments.)
        // Tool calls are where we have freedom for interesting UI/UX visualization beyond just the chat messages.
        // Example: write_html_page tool call will show the full html page in a modal.
        // Example 2: ChatGPT uses tool calls like Canvas to display their generated document/code.
        // Example 3: Rails Console Agent formats the terminal input commands and makes it look like a terminal.
        if (sender === "tool" || sender === "ai") {
          let formattedContent = formatMessage(text, sender);
          try {
            let json_payload = JSON.parse(text)
            let tool_name = json_payload.tool_name
            let tool_args = json_payload.tool_args
            
            if (tool_name == "write_html_page") {
              let full_html_page = tool_args['full_html_document']
              //TODO: set a minimal iFrame wrapper around the html page before inserting it.
              formattedContent = `
                <iframe src="data:text/html;charset=utf-8,${encodeURIComponent(full_html_page)}" width="100%" height="100%"></iframe>
                <div class="mt-4 text-center">
                  <button onclick="openPreview()" class="inline-flex items-center px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200 focus:outline-none focus:ring-4 focus:ring-blue-300">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    View Changes
                  </button>
                </div>
              `;
            }
            else if (tool_name == "clone_image_tool"){
              formattedContent = `
                <img src="${tool_args['image_url']}" alt="Cloned Image" class="w-full h-auto">
                <div class="mt-4 text-center">
                <h1> I'm looking at your image now! This might take a minute or two..</h1>
                </div>
              `;
            }
            else {
              formattedContent = formatMessage(text, sender);
            }
          } catch (error) {
            console.error("Error parsing tool payload:", error);
            formattedContent = formatMessage(text, sender);
          }

          messageDiv.innerHTML = formattedContent;
          chatbotMessagesContainer.appendChild(messageDiv);
          chatbotMessagesContainer.scrollTop = chatbotMessagesContainer.scrollHeight;
          return messageDiv;
        }
      }

      else { // this is an AIMessageChunk
        // Handle streaming AIMessageChunk with markdown rendering
        // If this is the first chunk, create a new message bubble
        if (!currentStreamingMessage) {
          currentStreamingMessage = document.createElement("div");
          currentStreamingMessage.className = "p-3 rounded-lg bg-gray-50 border border-gray-200 shadow-sm";
          currentStreamingMessage.innerHTML = `
            <div class="streaming-content"></div>
            <div class="typing-indicator inline-block w-1 h-4 bg-gray-400 animate-pulse ml-1"></div>
          `;
          chatbotMessagesContainer.appendChild(currentStreamingMessage);
          streamingMessageBuffer = '';
        }
        
        // Add the chunk to our buffer
        streamingMessageBuffer += text;
        
        // Update the message content using the existing formatMessage logic
        const contentDiv = currentStreamingMessage.querySelector('.streaming-content');
        const formattedContent = formatMessage(streamingMessageBuffer, "ai");
        contentDiv.innerHTML = formattedContent;
        
        // Auto-scroll to keep the message in view
        chatbotMessagesContainer.scrollTop = chatbotMessagesContainer.scrollHeight;
        return currentStreamingMessage;
      }
    }

    function finishStreamingMessage() {
      if (currentStreamingMessage) {
        // Remove typing indicator
        const typingIndicator = currentStreamingMessage.querySelector('.typing-indicator');
        if (typingIndicator) {
          typingIndicator.remove();
        }
        
        // Ensure Tailwind styles are applied to the final content
        ensureTailwindStyles();
        
        currentStreamingMessage = null;
        streamingMessageBuffer = '';
      }
    }



    // Force Tailwind to process dynamic content
    function ensureTailwindStyles() {
      // Method 1: Refresh Tailwind if available
      if (window.tailwind && window.tailwind.refresh) {
        window.tailwind.refresh();
      }
      
      // Method 2: Trigger a style recalculation
      const chatContainer = document.getElementById('chatbotMessagesContainer');
      if (chatContainer) {
        // Force browser to recalculate styles
        chatContainer.style.display = 'none';
        chatContainer.offsetHeight; // Trigger reflow
        chatContainer.style.display = '';
      }
    }
    /**
    * Sanitizes HTML content for safe preview in iframe during streaming.
    * Removes potentially problematic inline JavaScript that might execute before DOM is ready.
    * Preserves all external scripts (CDNs, frameworks, etc.) which are generally safe and necessary.
    */
    function sanitizeHtmlForPreview(html) {
      // Preserve ALL external scripts (those with src attributes) - they're generally safe and necessary
      const preservedScripts = [];
      const externalScriptPattern = /<script\b[^>]*src\s*=\s*["'][^"']*["'][^>]*><\/script>/gi;
      
      // Extract and preserve external scripts
      html = html.replace(externalScriptPattern, function(match) {
        preservedScripts.push(match);
        return `<!--PRESERVED_SCRIPT_${preservedScripts.length - 1}-->`;
      });
      
      // Only remove inline scripts (those without src) that might have DOM access issues
      html = html.replace(/<script\b(?![^>]*src\s*=)[^>]*>[\s\S]*?<\/script>/gi, function(match) {
        // If it's a simple script that doesn't seem to access DOM, keep it but wrap in try-catch
        if (match.length < 200 && !match.includes('document.') && !match.includes('getElementById') && !match.includes('querySelector')) {
          return match.replace(/(<script[^>]*>)([\s\S]*?)(<\/script>)/gi, function(full, openTag, content, closeTag) {
            return openTag + 'try { ' + content + ' } catch(e) { console.log("Preview script error:", e); }' + closeTag;
          });
        }
        return '<!-- Potentially problematic inline script removed for preview -->';
      });
      
      // Remove inline event handlers that might cause issues  
      html = html.replace(/\s*on\w+\s*=\s*["'][^"']*["']/gi, '');
      
      // Restore preserved external scripts
      preservedScripts.forEach((script, index) => {
        html = html.replace(`<!--PRESERVED_SCRIPT_${index}-->`, script);
      });
      
      return html;
    }

    /**
    * Updates the terminal display based on current mode
    */
    function updateTerminalModeDisplay() {
      const toggleButton = document.getElementById('terminalModeToggle');
      const terminalContent = document.getElementById('terminalContent');
      let cursor = document.getElementById('terminalCursor');
      
      // Clear any existing dots animation
      if (window.dotsInterval) {
        clearInterval(window.dotsInterval);
      }
      
      if (window.terminalMode === 'raw') {
        toggleButton.style.backgroundColor = '#ddd6fe';
        toggleButton.style.color = '#7c3aed';
        
        // Show character counter in raw mode
        const charCounter = document.getElementById('characterCounter');
        if (charCounter) {
          charCounter.style.display = 'block';
        }
        
        // In raw mode, show accumulated raw data with scrolling
        if (terminalContent) {
          terminalContent.textContent = '';
          
          let rawLines = [];
          
          // Show last bits of raw data if available
          if (window.terminalRawBuffer) {
            const lines = window.terminalRawBuffer.split('\n');
            const recentLines = lines.slice(-3).filter(line => line.trim()); // Last 3 non-empty lines
            recentLines.forEach(line => {
              if (line.length > 65) {
                line = line.substring(0, 62) + '...';
              }
              rawLines.push('üíª ' + line);
            });
          } else {
            rawLines.push('‚è≥ Waiting for code generation...');
          }
          
          const rawContent = rawLines.join('\n');
          terminalContent.appendChild(document.createTextNode(rawContent));
          
          // Create new cursor if it doesn't exist
          if (!cursor) {
            cursor = document.createElement('span');
            cursor.id = 'terminalCursor';
            cursor.textContent = '|';
            cursor.style.animation = 'blink 1s infinite';
            cursor.style.color = '#9ca3af';
            cursor.style.fontSize = '14px';
          }
          terminalContent.appendChild(cursor);
          
          // Auto-scroll to bottom
          if (window.terminalAutoScroll) {
            window.terminalAutoScroll();
          }
        }
      } else {
        toggleButton.style.backgroundColor = '#e5e7eb';
        toggleButton.style.color = '#6b7280';
        
        // Hide character counter in explanation mode
        const charCounter = document.getElementById('characterCounter');
        if (charCounter) {
          charCounter.style.display = 'none';
        }
        
        // In explanation mode, show the current explanation
        if (terminalContent && cursor) {
          updateExplanationDisplay();
        }
      }
    }

    /**
    * Updates the explanation display with animated dots
    */
    function updateExplanationDisplay() {
      if (window.terminalMode !== 'explanation') return;
      
      const terminalContent = document.getElementById('terminalContent');
      let cursor = document.getElementById('terminalCursor');
      
      if (terminalContent) {
        // Clear any existing dots animation
        if (window.dotsInterval) {
          clearInterval(window.dotsInterval);
        }
        
        // Clear content but preserve/recreate cursor
        terminalContent.textContent = '';
        
        let displayLines = [];
        
        // Show last few completed tasks
        if (window.completedExplanations && window.completedExplanations.length > 0) {
          const recentCompleted = window.completedExplanations.slice(-4, -1); // Last 3 completed tasks, excluding the most recent
          recentCompleted.forEach(explanation => {
            let line = '‚úÖ ' + explanation.trim();
            if (line.length > 65) {
              line = line.substring(0, 62) + '...';
            }
            displayLines.push(line);
          });
        }
        
        // Show current task (but avoid showing the same task as both completed and current)
        let currentLine = '';
        let currentTask = window.currentCodeExplanationFromLLM && window.currentCodeExplanationFromLLM.trim();
        
        // Check if current task is already in completed list (avoid duplicates)
        let isAlreadyCompleted = false;
        if (currentTask && window.completedExplanations) {
          isAlreadyCompleted = window.completedExplanations.some(completed => 
            completed.trim() === currentTask
          );
        }
        
        if (currentTask) {
          currentLine = '‚ö° ' + currentTask;
        }

        
        if (currentLine.length > 65) {
          currentLine = currentLine.substring(0, 62) + '...';
        }
        displayLines.push(currentLine);
        
        // Join lines and add to terminal
        const displayText = displayLines.join('\n');
        const textNode = document.createTextNode(displayText);
        terminalContent.appendChild(textNode);
        
        const dotsSpan = document.createElement('span');
        dotsSpan.id = 'animatedDots';
        terminalContent.appendChild(dotsSpan);
        
        // Create new cursor if it doesn't exist
        if (!cursor) {
          cursor = document.createElement('span');
          cursor.id = 'terminalCursor';
          cursor.textContent = '|';
          cursor.style.animation = 'blink 1s infinite';
          cursor.style.color = '#9ca3af';
          cursor.style.fontSize = '14px';
        }
        terminalContent.appendChild(cursor);
        
        // Start dots animation
        startDotsAnimation();
        
        // Auto-scroll to bottom
        if (window.terminalAutoScroll) {
          window.terminalAutoScroll();
        }
      }
    }

    /**
    * Animates the dots (...) with cycling pattern
    */
    function startDotsAnimation() {
      const dotsSpan = document.getElementById('animatedDots');
      if (!dotsSpan) return;
      
      let dotCount = 0;
      window.dotsInterval = setInterval(() => {
        if (window.terminalMode !== 'explanation') {
          clearInterval(window.dotsInterval);
          return;
        }
        
        dotCount = (dotCount + 1) % 4; // Cycle through 0, 1, 2, 3
        dotsSpan.textContent = '.'.repeat(dotCount);
      }, 500); // Change every 500ms
    }

    /**
    * Clears the terminal and shows startup message
    */
    function initializeTerminal() {
      const terminalContent = document.getElementById('terminalContent');
      const cursor = document.getElementById('terminalCursor');
      
      if (terminalContent && cursor) {
        terminalContent.textContent = '';
        window.terminalBytesReceived = 0; // Reset byte counter
        window.terminalRawBuffer = ''; // Reset raw data buffer
        window.terminalMode = 'explanation'; // Default to explanation mode
        window.currentCodeExplanationFromLLM = ''; // Reset explanation
        window.completedExplanations = []; // Reset completed explanations history
        
        // Initialize character counter
        if (window.updateCharacterCounter) {
          window.updateCharacterCounter();
        }
        
        updateExplanationDisplay();
      }
    }

    /**
    * Adds text to the streaming terminal window and accumulates raw data
    */
    function addToTerminal(text) {
      // Always accumulate raw data in buffer
      window.terminalRawBuffer = (window.terminalRawBuffer || '') + text;
      window.terminalBytesReceived = (window.terminalBytesReceived || 0) + text.length;
      
      // Update character counter
      if (window.updateCharacterCounter) {
        window.updateCharacterCounter();
      }
      
      // Limit buffer size to prevent memory issues
      if (window.terminalRawBuffer.length > 10000) {
        window.terminalRawBuffer = '...[truncated]...\n' + window.terminalRawBuffer.slice(-8000);
      }
      
      // Only show raw code in raw mode, and update the simple display
      if (window.terminalMode === 'raw') {
        updateTerminalModeDisplay();
      }
    }

    /**
    * This function handles the fragment from the html stream and constructs the modal that displays it to the user.
    */
    function handleFragment(text) {
      let modal = document.getElementById('fragmentModal');
      
      // Declare timers outside the modal creation block so they persist across calls
      if (!window.fragmentTimers) {
        window.fragmentTimers = {
          flushTimer: null,
          scrollTimeout: null
        };
      }
      
      if (!modal) {
        // Create modal container with basic styles
        modal = document.createElement('div');
        modal.id = 'fragmentModal';
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.zIndex = '10000';

        // Create the iframe container
        const iframeContainer = document.createElement('div');
        iframeContainer.style.width = '80%';
        iframeContainer.style.height = '80%';
        iframeContainer.style.backgroundColor = '#fff';
        iframeContainer.style.borderRadius = '8px';
        iframeContainer.style.position = 'relative';

        // Create the iframe
        const iframe = document.createElement('iframe');
        iframe.id = 'fragmentIframe';
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.style.borderRadius = '8px';

        // Create simple terminal window
        const terminalWindow = document.createElement('div');
        terminalWindow.id = 'streamingTerminal';
        terminalWindow.style.position = 'absolute';
        terminalWindow.style.bottom = '20px';
        terminalWindow.style.right = '20px';
        terminalWindow.style.width = '420px';
        terminalWindow.style.height = '90px';
        terminalWindow.style.backgroundColor = '#f8f9fa';
        terminalWindow.style.border = '1px solid #e1e5e9';
        terminalWindow.style.borderRadius = '12px';
        terminalWindow.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        terminalWindow.style.fontSize = '14px';
        terminalWindow.style.color = '#374151';
        terminalWindow.style.zIndex = '10';
        terminalWindow.style.boxShadow = '0 4px 20px rgba(0,0,0,0.1)';
        terminalWindow.style.display = 'flex';
        terminalWindow.style.flexDirection = 'column';
        terminalWindow.style.padding = '12px 16px';
        terminalWindow.style.gap = '8px';

        // Toggle button for switching modes
        const toggleButton = document.createElement('button');
        toggleButton.id = 'terminalModeToggle';
        toggleButton.textContent = '{}';
        toggleButton.style.backgroundColor = '#e5e7eb';
        toggleButton.style.color = '#6b7280';
        toggleButton.style.border = 'none';
        toggleButton.style.borderRadius = '8px';
        toggleButton.style.padding = '6px 8px';
        toggleButton.style.fontSize = '12px';
        toggleButton.style.cursor = 'pointer';
        toggleButton.style.fontFamily = 'monospace';
        toggleButton.style.flexShrink = '0';
        toggleButton.style.transition = 'all 0.2s ease';
        toggleButton.title = 'View code details';
        
        toggleButton.addEventListener('mouseenter', function() {
          this.style.backgroundColor = '#d1d5db';
          this.style.transform = 'scale(1.05)';
        });
        
        toggleButton.addEventListener('mouseleave', function() {
          this.style.backgroundColor = '#e5e7eb';
          this.style.transform = 'scale(1)';
        });
        
        toggleButton.addEventListener('click', function() {
          window.terminalMode = window.terminalMode === 'explanation' ? 'raw' : 'explanation';
          updateTerminalModeDisplay();
        });

        // Terminal content area
        const terminalContent = document.createElement('div');
        terminalContent.id = 'terminalContent';
        terminalContent.style.flex = '1';
        terminalContent.style.overflow = 'auto';
        terminalContent.style.whiteSpace = 'pre-wrap';
        terminalContent.style.wordBreak = 'break-word';
        terminalContent.style.lineHeight = '1.5';
        terminalContent.style.maxHeight = '66px'; // 3 lines at ~22px each
        
        // Auto-scroll function
        window.terminalAutoScroll = function() {
          if (terminalContent) {
            terminalContent.scrollTop = terminalContent.scrollHeight;
          }
        };
        
        // Character counter update function
        window.updateCharacterCounter = function() {
          const counter = document.getElementById('characterCounter');
          if (counter) {
            const count = window.terminalBytesReceived || 0;
            counter.textContent = `${count.toLocaleString()} chars`;
          }
        };
        
        // Cursor
        const cursor = document.createElement('span');
        cursor.id = 'terminalCursor';
        cursor.textContent = '|';
        cursor.style.animation = 'blink 1s infinite';
        cursor.style.color = '#9ca3af';
        cursor.style.fontSize = '14px';

        // Add blinking animation
        if (!document.querySelector('#terminal-blink-style')) {
          const style = document.createElement('style');
          style.id = 'terminal-blink-style';
          style.textContent = `
            @keyframes blink {
              0%, 50% { opacity: 1; }
              51%, 100% { opacity: 0; }
            }
          `;
          document.head.appendChild(style);
        }

        // Create main content row (content + button)
        const mainRow = document.createElement('div');
        mainRow.style.display = 'flex';
        mainRow.style.alignItems = 'center';
        mainRow.style.gap = '12px';
        mainRow.style.flex = '1';
        
        // Create character counter (will be positioned near toggle button)
        const charCounter = document.createElement('div');
        charCounter.id = 'characterCounter';
        charCounter.style.fontSize = '10px';
        charCounter.style.color = '#9ca3af';
        charCounter.style.textAlign = 'center';
        charCounter.style.marginTop = '4px';
        charCounter.style.display = 'none'; // Hidden by default (starts in explanation mode)
        charCounter.textContent = '0 chars';
        
        // Create right column for toggle button and counter
        const rightColumn = document.createElement('div');
        rightColumn.style.display = 'flex';
        rightColumn.style.flexDirection = 'column';
        rightColumn.style.alignItems = 'center';
        rightColumn.style.gap = '4px';
        
        // Assemble terminal
        rightColumn.appendChild(toggleButton);
        rightColumn.appendChild(charCounter);
        mainRow.appendChild(terminalContent);
        mainRow.appendChild(rightColumn);
        terminalWindow.appendChild(mainRow);
        terminalContent.appendChild(cursor);

        // Create overlay div
        const overlay = document.createElement('div');
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.background = 'rgba(0, 0, 0, 0.4)';
        overlay.style.display = 'flex';
        overlay.style.flexDirection = 'column';
        overlay.style.alignItems = 'center';
        overlay.style.zIndex = '1';
        overlay.style.borderTopLeftRadius = '8px';
        overlay.style.borderTopRightRadius = '8px';
        
        // Create text for overlay
        const overlayText = document.createElement('div');
        overlayText.textContent = 'Your Page is Being Built!';
        overlayText.style.color = 'white';
        overlayText.style.fontSize = '52px';
        overlayText.style.fontWeight = 'bold';
        overlayText.style.fontFamily = 'Arial, sans-serif';

        // Create text container for the top
        const textContainer = document.createElement('div');
        textContainer.style.padding = '30px';
        textContainer.style.width = '100%';
        textContainer.style.textAlign = 'center';

        // Create Lottie container
        const lottieContainer = document.createElement('div');
        lottieContainer.id = 'lottieAnimation';
        lottieContainer.style.width = '300px';
        lottieContainer.style.height = '300px';
        lottieContainer.style.position = 'absolute';
        lottieContainer.style.top = '50%';
        lottieContainer.style.left = '50%';
        lottieContainer.style.transform = 'translate(-50%, -50%)';

        // Add script for Lottie if not already present
        if (!document.querySelector('script[src*="lottie-player"]')) {
          const lottieScript = document.createElement('script');
          lottieScript.src = "https://unpkg.com/@dotlottie/player-component@latest/dist/dotlottie-player.js";
          document.head.appendChild(lottieScript);
        }

        // Create Lottie player element
        const lottiePlayer = document.createElement('dotlottie-player');
        //lottiePlayer.src = "https://llamapress-ai-image-uploads.s3.us-west-2.amazonaws.com/c8lbj2yhvu5vi0gt55un8wyxczio"; // 
        //lottiePlayer.src = "https://llamapress-ai-image-uploads.s3.us-west-2.amazonaws.com/dkm4k1wfacwyyqtzx1tsow0rdbgx"; // Builder Image.
        lottiePlayer.src = "https://llamapress-ai-image-uploads.s3.us-west-2.amazonaws.com/hffa8kqjfn9yzfx28pogpvqhn7cd"; // Builder Image.
        
        lottiePlayer.background = "transparent";
        lottiePlayer.speed = "1";
        lottiePlayer.style.width = "300px";
        lottiePlayer.style.height = "300px";
        lottiePlayer.setAttribute("autoplay", "");
        lottiePlayer.setAttribute("loop", "");

        // Append all elements
        textContainer.appendChild(overlayText);
        lottieContainer.appendChild(lottiePlayer);
        overlay.appendChild(textContainer);
        overlay.appendChild(lottieContainer);
        iframeContainer.appendChild(overlay);
        iframeContainer.appendChild(iframe);
        iframeContainer.appendChild(terminalWindow);
        modal.appendChild(iframeContainer);
        document.body.appendChild(modal);

        // Add a buffer property to the modal
        modal.htmlBuffer = '';
        
        // Initialize the terminal with startup message (wait for DOM to be ready)
        setTimeout(() => {
          initializeTerminal();
        }, 200);
      }

      modal.style.display = 'flex';
      const iframe = document.getElementById('fragmentIframe');
      const REFRESH_MS      = 500;          // adjust to taste (500ms ‚âà‚ÄØ2‚ÄØfps)

      modal.htmlBuffer = modal.htmlBuffer || '';

      function streamToken(text) {
        modal.htmlBuffer += text;          // keep buffering
        addToTerminal(text);               // your existing terminal output

        // schedule a single flush if none is queued
        if (!window.fragmentTimers.flushTimer) {
          window.fragmentTimers.flushTimer = setTimeout(flushIframe, REFRESH_MS);
        }
      }


      function flushIframe() {
        try {
          const cleanedHTML = sanitizeHtmlForPreview(
            modal.htmlBuffer
              .replace(/\\n/g, '\n')
              .replace(/\\"/g, '"')
              .replace(/\\t/g, '\t')
              .replace(/\\r/g, '\r')
          );

          const iframeDoc = iframe.contentDocument;
          if (iframeDoc) {
            iframeDoc.open();
            iframeDoc.write(cleanedHTML);
            iframeDoc.close();

            // Improved iframe height and scroll handling with error protection
            clearTimeout(window.fragmentTimers.scrollTimeout);
            window.fragmentTimers.scrollTimeout = setTimeout(() => {
              try {
                // Get the iframe container
                const iframeContainer = iframe.parentElement;
                
                // Calculate the maximum available height (80% of viewport height as per the container style)
                const maxHeight = window.innerHeight * 0.8;
                
                // Safely get the content height with null checks
                let contentHeight = 300; // Default fallback height
                if (iframeDoc && iframeDoc.documentElement && iframeDoc.body) {
                  contentHeight = Math.max(
                    iframeDoc.documentElement.scrollHeight || 0,
                    iframeDoc.documentElement.offsetHeight || 0,
                    iframeDoc.documentElement.clientHeight || 0,
                    iframeDoc.body.scrollHeight || 0,
                    iframeDoc.body.offsetHeight || 0
                  );
                }

                // Set iframe height to either content height or max height, whichever is smaller
                iframe.style.height = Math.min(contentHeight, maxHeight) + 'px';
                
                // Enable scrolling if content is taller than available space
                iframe.style.overflowY = contentHeight > maxHeight ? 'auto' : 'hidden';
                
                // Ensure the iframe container doesn't exceed viewport
                if (iframeContainer) {
                  iframeContainer.style.maxHeight = '80vh';
                  iframeContainer.style.overflowY = 'hidden';
                }
                
                // Safely scroll to bottom
                if (iframeDoc && iframeDoc.documentElement) {
                  iframeDoc.documentElement.scrollTop = iframeDoc.documentElement.scrollHeight;
                }
                if (iframeDoc && iframeDoc.body) {
                  iframeDoc.body.scrollTop = iframeDoc.body.scrollHeight;
                }
              } catch (scrollError) {
                console.log('Error adjusting iframe height/scroll (safe to ignore):', scrollError);
              }
            }, 600);
            
          } else {
            console.warn('Iframe document not accessible');
          }
        } catch (e) {
          console.log('Error processing HTML fragment (this is normal during streaming):', e);
          // Don't throw the error, just log it as this is expected during streaming
        } finally {
          // Clear the timer at the very end to allow next schedule
          window.fragmentTimers.flushTimer = null;
        }
      }
      
      if (typeof text === 'string') {
        
        // Use the buffered approach for better performance
        streamToken(text);
      } else {
        console.error('Unexpected content type:', text);
      }
    }

    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }


    function showLoadingIndicator() {
      const spinner = makeLoadingSpinner();
      const loadingDiv = document.createElement("div");
      loadingDiv.id = "loadingIndicator";
      loadingDiv.appendChild(spinner);
      chatbotMessagesContainer.appendChild(loadingDiv);
    }

    function hideLoadingIndicator() {
      const loadingDiv = document.getElementById("loadingIndicator");
      if (loadingDiv) {
        loadingDiv.remove();
      }
    }

    function autoResizeUserInputArea() {
        textarea.style.height = 'auto';
        const newHeight = Math.min(textarea.scrollHeight, textarea.rows * 24 * maxRows);
        textarea.style.height = newHeight + 'px';
        //minimum make it 2 rows
        if (newHeight < 24) {
          textarea.style.height = '24px';
        }
    }
    /**
     * WARNING: This is duplicated code in _websocket.html.erb. This is really ugly. Formats the message to display code blocks properly
     * This was used to format code blocks so that the user could see formatted code when the chatbot responds.
     */
    function formatMessage(text, sender) {
      // Custom renderer to handle code blocks
      const renderer = new marked.Renderer();
      renderer.code = (code) => {
        return code;
      };

      // Configure marked options
      marked.setOptions({
        renderer: renderer,
        highlight: (code, lang) => {
          const language = Prism.languages[lang] ? lang : 'markup';
          return Prism.highlight(code, Prism.languages[language], language);
        },
        breaks: true,
        gfm: true
      });

      // Parse the markdown
      if (sender == "user") {
        return marked.parse(escapeHtml(text));
      }
      else {
        return marked.parse(text);
      }
    }

/**
 * This is the button handler for when the user clicks "send" on the chatbot.
 */
async function sendUserMessageOverSocket(userMessage, selectedElementInnerHtml, errorCallback, javaScriptConsoleErrors) {
  try {
    // Create a promise that resolves when the connection is ready
    const waitForConnection = () => {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 150; // 5 seconds (100ms * 50)
        
        const checkConnection = () => {
          if (chatChannel && !chatChannel.consumer.connection.disconnected) {
            resolve();
          } else if (attempts >= maxAttempts) {
            reject(new Error("Connection timeout"));
          } else {
            attempts++;
            setTimeout(checkConnection, 100); // Check every 100ms
          }
        };
        checkConnection();
      });
    };

    // Wait for connection before proceeding
    await waitForConnection();

    // Rest of your existing send logic
    if (window.selectedImages && window.selectedImages.size > 0) {
      userMessage += "\n\nThe user selected the following images:\n" + 
        Array.from(window.selectedImages).join('\n');
      
      window.selectedImages.clear();
      
      document.querySelectorAll('#image-container img').forEach(img => {
        img.classList.remove('border-2', 'border-red-500', 'shadow-md', 'shadow-red-200');
      });
    }

    const sendButton = document.getElementById('sendButton');
    sendButton.textContent = 'Cancel';
    sendButton.classList.remove('bg-blue-500', 'hover:bg-blue-600');
    sendButton.classList.add('bg-red-500', 'hover:bg-red-600');
    
    // Your existing cancel handler code
    const cancelHandler = () => {
      console.log("Cancel Sent");
      
      const thinkingElement = document.querySelector('.thinking-pulse');
      if (thinkingElement) {
        thinkingElement.textContent = 'Cancelling...';
      }
      
      sendButton.textContent = 'Cancelling...';
      sendButton.disabled = true;
      
      chatChannel.send({
        user_message: "cancel",
        type: "cancel",
        message_type: "cancel",
        context: "<%=@view_path%>",
        webPageId: "<%=@page&.id%>",
      });
      
      setTimeout(() => {
        sendButton.disabled = false;
        sendButton.textContent = 'Send';
        sendButton.classList.remove('bg-red-500', 'hover:bg-red-600');
        sendButton.classList.add('bg-blue-500', 'hover:bg-blue-600');
      }, 1000);
    };
    
    if (!sessionId) {
      console.error("Session ID not available");
      errorCallback(new Error("Session ID not available"));
      return;
    }

    chatChannel.send({
      raw_params: <%= raw params.to_json %>,
      message: userMessage,
      thread_id: sessionId, // Use session ID as thread ID for conversation tracking
      context: "<%=@view_path%>",
      selected_element: selectedElementInnerHtml,
      page_id: "<%=@page&.id%>",
      message_type: "message",
      javascript_console_errors: javaScriptConsoleErrors
    });
  } catch (error) {
    console.error("Error sending message:", error);
    errorCallback(error);
  }
}
window.sendUserMessageOverSocket = sendUserMessageOverSocket;
    
</script>
<script src="https://cdn.jsdelivr.net/npm/@rails/actioncable@7.0.0" onload="initializeChat(); handleChatUrlParams()"></script>

